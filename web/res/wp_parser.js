/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var bundle;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./grammar/eberban.js":
/*!****************************!*\
  !*** ./grammar/eberban.js ***!
  \****************************/
/***/ ((module) => {

eval("var camxes = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { text: peg$parsetext },\n        peg$startRuleFunction  = peg$parsetext,\n\n        peg$c0 = peg$FAILED,\n        peg$c1 = [],\n        peg$c2 = null,\n        peg$c3 = function(expr) {return _node(\"text\", expr);},\n        peg$c4 = void 0,\n        peg$c5 = function(expr) {return _node(\"paragraphs\", expr);},\n        peg$c6 = function(expr) {return _node(\"paragraph\", expr);},\n        peg$c7 = function(expr) {return _node(\"paragraph_unit\", expr);},\n        peg$c8 = function(expr) {return _node(\"paragraph_unit_erased\", expr);},\n        peg$c9 = function(expr) {return _node(\"paragraph_unit_1\", expr);},\n        peg$c10 = function(expr) {return _node(\"arguments_list\", expr);},\n        peg$c11 = function(expr) {return _node(\"definition\", expr);},\n        peg$c12 = function(expr) {return _node(\"defined\", expr);},\n        peg$c13 = function(expr) {return _node(\"sentence\", expr);},\n        peg$c14 = function(expr) {return _node(\"scope\", expr);},\n        peg$c15 = function(expr) {return _node(\"scope_1\", expr);},\n        peg$c16 = function(expr) {return _node(\"scope_sequence\", expr);},\n        peg$c17 = function(expr) {return _node(\"scope_sequence_item\", expr);},\n        peg$c18 = function(expr) {return _node(\"scope_2\", expr);},\n        peg$c19 = function(expr) {return _node(\"chaining\", expr);},\n        peg$c20 = function(expr) {return _node(\"chaining_neg\", expr);},\n        peg$c21 = function(expr) {return _node(\"chaining_unit\", expr);},\n        peg$c22 = function(expr) {return _node(\"ve_scope\", expr);},\n        peg$c23 = function(expr) {return _node(\"ve_scope_first\", expr);},\n        peg$c24 = function(expr) {return _node(\"ve_scope_next\", expr);},\n        peg$c25 = function(expr) {return _node(\"predicate\", expr);},\n        peg$c26 = function(expr) {return _node(\"predicate_1\", expr);},\n        peg$c27 = function(expr) {return _node(\"predicate_2\", expr);},\n        peg$c28 = function(expr) {return _node(\"predicate_root\", expr);},\n        peg$c29 = function(expr) {return _node(\"predicate_number\", expr);},\n        peg$c30 = function(expr) {return _node(\"predicate_compound\", expr);},\n        peg$c31 = function(expr) {return _node(\"predicate_borrowing\", expr);},\n        peg$c32 = function(expr) {return _node(\"predicate_scope\", expr);},\n        peg$c33 = function(expr) {return _node(\"predicate_quote\", expr);},\n        peg$c34 = function(expr) {return _node(\"grammatical_quote\", expr);},\n        peg$c35 = function(expr) {return _node(\"one_word_quote\", expr);},\n        peg$c36 = function(expr) {return _node(\"foreign_quote\", expr);},\n        peg$c37 = { type: \"any\", description: \"any character\" },\n        peg$c38 = function(expr) { return [\"foreign_quote_content\", _join(expr)]; },\n        peg$c39 = function(expr) {return _node(\"number\", expr);},\n        peg$c40 = function(expr) {return _node(\"borrowing_group\", expr);},\n        peg$c41 = function(expr) {return _node(\"predicate_variable\", expr);},\n        peg$c42 = function(expr) {return _node(\"override\", expr);},\n        peg$c43 = function(expr) {return _node(\"free\", expr);},\n        peg$c44 = function(expr) {return _node(\"free_metadata\", expr);},\n        peg$c45 = function(expr) {return _node(\"free_subscript\", expr);},\n        peg$c46 = function(expr) {return _node(\"free_parenthetical\", expr);},\n        peg$c47 = function(expr) {return _node(\"free_interjection\", expr);},\n        peg$c48 = function(expr) {return _node(\"BA_clause\", expr);},\n        peg$c49 = function(expr) {return _node(\"BE_clause\", expr);},\n        peg$c50 = function(expr) {return _node(\"BI_clause\", expr);},\n        peg$c51 = function(expr) {return _node(\"BO_clause\", expr);},\n        peg$c52 = function(expr) {return _node(\"BU_clause\", expr);},\n        peg$c53 = function(expr) {return _node(\"DA_clause\", expr);},\n        peg$c54 = function(expr) {return _node(\"DE_clause\", expr);},\n        peg$c55 = function(expr) {return _node(\"DI_clause\", expr);},\n        peg$c56 = function(expr) {return _node(\"DO_clause\", expr);},\n        peg$c57 = function(expr) {return _node(\"DOI_clause\", expr);},\n        peg$c58 = function(expr) {return _node(\"DU_clause\", expr);},\n        peg$c59 = function(expr) {return _node(\"SE_clause\", expr);},\n        peg$c60 = function(expr) {return _node(\"ZI_clause\", expr);},\n        peg$c61 = function(expr) {return _node(\"VE_clause\", expr);},\n        peg$c62 = function(expr) {return _node(\"FE_clause\", expr);},\n        peg$c63 = function(expr) {return _node(\"VEI_clause\", expr);},\n        peg$c64 = function(expr) {return _node(\"GI_clause\", expr);},\n        peg$c65 = function(expr) {return _node(\"KI_clause\", expr);},\n        peg$c66 = function(expr) {return _node(\"MI_clause\", expr);},\n        peg$c67 = function(expr) {return _node(\"PA_clause\", expr);},\n        peg$c68 = function(expr) {return _node(\"PAI_clause\", expr);},\n        peg$c69 = function(expr) {return _node(\"PE_clause\", expr);},\n        peg$c70 = function(expr) {return _node(\"PEI_clause\", expr);},\n        peg$c71 = function(expr) {return _node(\"PI_clause\", expr);},\n        peg$c72 = function(expr) {return _node(\"PO_clause\", expr);},\n        peg$c73 = function(expr) {return _node(\"POI_clause\", expr);},\n        peg$c74 = function(expr) {return _node(\"PU_clause\", expr);},\n        peg$c75 = function(expr) {return _node(\"TI_clause\", expr);},\n        peg$c76 = function(expr) {return _node(\"CA_clause\", expr);},\n        peg$c77 = function(expr) {return _node(\"CAI_clause\", expr);},\n        peg$c78 = function(expr) {return _node(\"CE_clause\", expr);},\n        peg$c79 = function(expr) {return _node(\"CO_clause\", expr);},\n        peg$c80 = function(expr) {return _node(\"CU_clause\", expr);},\n        peg$c81 = function(expr) {return (expr == \"\" || !expr) ? [\"BE\"] : _node_empty(\"BE_clause_elidible\", expr);},\n        peg$c82 = function(expr) {return (expr == \"\" || !expr) ? [\"PA\"] : _node_empty(\"PA_clause_elidible\", expr);},\n        peg$c83 = function(expr) {return (expr == \"\" || !expr) ? [\"PAI\"] : _node_empty(\"PAI_clause_elidible\", expr);},\n        peg$c84 = function(expr) {return (expr == \"\" || !expr) ? [\"PEI\"] : _node_empty(\"PEI_clause_elidible\", expr);},\n        peg$c85 = function(expr) {return (expr == \"\" || !expr) ? [\"POI\"] : _node_empty(\"POI_clause_elidible\", expr);},\n        peg$c86 = function(expr) {return (expr == \"\" || !expr) ? [\"VEI\"] : _node_empty(\"VEI_clause_elidible\", expr);},\n        peg$c87 = function(expr) {return _node(\"BA\", expr);},\n        peg$c88 = function(expr) {return _node(\"BE\", expr);},\n        peg$c89 = function(expr) {return _node(\"BI\", expr);},\n        peg$c90 = function(expr) {return _node(\"BO\", expr);},\n        peg$c91 = function(expr) {return _node(\"BU\", expr);},\n        peg$c92 = function(expr) {return _node(\"CA\", expr);},\n        peg$c93 = function(expr) {return _node(\"CAI\", expr);},\n        peg$c94 = function(expr) {return _node(\"CE\", expr);},\n        peg$c95 = function(expr) {return _node(\"CO\", expr);},\n        peg$c96 = function(expr) {return _node(\"CU\", expr);},\n        peg$c97 = function(expr) {return _node(\"DA\", expr);},\n        peg$c98 = function(expr) {return _node(\"DE\", expr);},\n        peg$c99 = function(expr) {return _node(\"DI\", expr);},\n        peg$c100 = function(expr) {return _node(\"DO\", expr);},\n        peg$c101 = function(expr) {return _node(\"DOI\", expr);},\n        peg$c102 = function(expr) {return _node(\"DU\", expr);},\n        peg$c103 = function(expr) {return _node(\"FE\", expr);},\n        peg$c104 = function(expr) {return _node(\"GI\", expr);},\n        peg$c105 = function(expr) {return _node(\"KI\", expr);},\n        peg$c106 = function(expr) {return _node(\"MI\", expr);},\n        peg$c107 = function(expr) {return _node(\"PA\", expr);},\n        peg$c108 = function(expr) {return _node(\"PAI\", expr);},\n        peg$c109 = function(expr) {return _node(\"PE\", expr);},\n        peg$c110 = function(expr) {return _node(\"PEI\", expr);},\n        peg$c111 = function(expr) {return _node(\"PI\", expr);},\n        peg$c112 = function(expr) {return _node(\"PO\", expr);},\n        peg$c113 = function(expr) {return _node(\"POI\", expr);},\n        peg$c114 = function(expr) {return _node(\"PU\", expr);},\n        peg$c115 = function(expr) {return _node(\"SE\", expr);},\n        peg$c116 = function(expr) {return _node(\"TI\", expr);},\n        peg$c117 = function(expr) {return _node(\"VE\", expr);},\n        peg$c118 = function(expr) {return _node(\"VEI\", expr);},\n        peg$c119 = function(expr) {return _node(\"ZI\", expr);},\n        peg$c120 = function(expr) { _assign_foreign_quote_delim(expr); return _node(\"foreign_quote_open\", expr); },\n        peg$c121 = function(expr) {return _node(\"foreign_quote_word\", expr);},\n        peg$c122 = function(expr) { return _is_foreign_quote_delim(expr); },\n        peg$c123 = function(expr) { return _node(\"foreign_quote_close\", expr); },\n        peg$c124 = function(expr) {return _node(\"compound\", expr);},\n        peg$c125 = function(expr) {return _node(\"compound_2\", expr);},\n        peg$c126 = function(expr) {return _node(\"compound_3\", expr);},\n        peg$c127 = function(expr) {return _node(\"compound_n\", expr);},\n        peg$c128 = function(expr) {return _node(\"compound_n_end\", expr);},\n        peg$c129 = function(expr) {return _node(\"compound_word\", expr);},\n        peg$c130 = function(expr) {return _node(\"freeform_variable\", expr);},\n        peg$c131 = function(expr) {return _node(\"borrowing\", expr);},\n        peg$c132 = function(expr) {return _node(\"freeform_content\", expr);},\n        peg$c133 = function(expr) {return _node(\"freeform_end\", expr);},\n        peg$c134 = function(expr) {return _node(\"native_word\", expr);},\n        peg$c135 = function(expr) {return _node(\"particle\", expr);},\n        peg$c136 = function(expr) {return _node(\"root\", expr);},\n        peg$c137 = function(expr) {return _node(\"particle_1\", expr);},\n        peg$c138 = function(expr) {return _node(\"root_1\", expr);},\n        peg$c139 = function(expr) {return _node(\"root_2\", expr);},\n        peg$c140 = function(expr) {return _node(\"root_3\", expr);},\n        peg$c141 = function(expr) {return _node(\"hieaou\", expr);},\n        peg$c142 = function(expr) {return _node(\"ieaou\", expr);},\n        peg$c143 = function(expr) {return _node(\"consonant_cluster\", expr);},\n        peg$c144 = function(expr) {return _node(\"consonant_cluster_1\", expr);},\n        peg$c145 = function(expr) {return _node(\"consonant_cluster_2\", expr);},\n        peg$c146 = function(expr) {return _node(\"medial_pair\", expr);},\n        peg$c147 = function(expr) {return _node(\"medial_patterns\", expr);},\n        peg$c148 = function(expr) {return _node(\"medial_n\", expr);},\n        peg$c149 = function(expr) {return _node(\"medial_fv\", expr);},\n        peg$c150 = function(expr) {return _node(\"medial_plosive\", expr);},\n        peg$c151 = function(expr) {return _node(\"initial_pair\", expr);},\n        peg$c152 = function(expr) {return _node(\"initial\", expr);},\n        peg$c153 = function(expr) {return _node(\"other\", expr);},\n        peg$c154 = function(expr) {return _node(\"plosive\", expr);},\n        peg$c155 = function(expr) {return _node(\"sibilant\", expr);},\n        peg$c156 = function(expr) {return _node(\"sonorant\", expr);},\n        peg$c157 = function(expr) {return _node(\"consonant\", expr);},\n        peg$c158 = function(expr) {return _node(\"nasal\", expr);},\n        peg$c159 = function(expr) {return _node(\"liquid\", expr);},\n        peg$c160 = function(expr) {return _node(\"voiced\", expr);},\n        peg$c161 = function(expr) {return _node(\"unvoiced\", expr);},\n        peg$c162 = function(expr) {return _node(\"vowel\", expr);},\n        peg$c163 = /^[iI]/,\n        peg$c164 = { type: \"class\", value: \"[iI]\", description: \"[iI]\" },\n        peg$c165 = function(expr) {return [\"i\", \"i\"];},\n        peg$c166 = /^[eE]/,\n        peg$c167 = { type: \"class\", value: \"[eE]\", description: \"[eE]\" },\n        peg$c168 = function(expr) {return [\"e\", \"e\"];},\n        peg$c169 = /^[aA]/,\n        peg$c170 = { type: \"class\", value: \"[aA]\", description: \"[aA]\" },\n        peg$c171 = function(expr) {return [\"a\", \"a\"];},\n        peg$c172 = /^[oO]/,\n        peg$c173 = { type: \"class\", value: \"[oO]\", description: \"[oO]\" },\n        peg$c174 = function(expr) {return [\"o\", \"o\"];},\n        peg$c175 = /^[uU]/,\n        peg$c176 = { type: \"class\", value: \"[uU]\", description: \"[uU]\" },\n        peg$c177 = function(expr) {return [\"u\", \"u\"];},\n        peg$c178 = /^[hH]/,\n        peg$c179 = { type: \"class\", value: \"[hH]\", description: \"[hH]\" },\n        peg$c180 = function(expr) {return [\"h\", \"h\"];},\n        peg$c181 = /^[nN]/,\n        peg$c182 = { type: \"class\", value: \"[nN]\", description: \"[nN]\" },\n        peg$c183 = function(expr) {return [\"n\", \"n\"];},\n        peg$c184 = /^[rR]/,\n        peg$c185 = { type: \"class\", value: \"[rR]\", description: \"[rR]\" },\n        peg$c186 = function(expr) {return [\"r\", \"r\"];},\n        peg$c187 = /^[lL]/,\n        peg$c188 = { type: \"class\", value: \"[lL]\", description: \"[lL]\" },\n        peg$c189 = function(expr) {return [\"l\", \"l\"];},\n        peg$c190 = /^[mM]/,\n        peg$c191 = { type: \"class\", value: \"[mM]\", description: \"[mM]\" },\n        peg$c192 = function(expr) {return [\"m\", \"m\"];},\n        peg$c193 = /^[pP]/,\n        peg$c194 = { type: \"class\", value: \"[pP]\", description: \"[pP]\" },\n        peg$c195 = function(expr) {return [\"p\", \"p\"];},\n        peg$c196 = /^[bB]/,\n        peg$c197 = { type: \"class\", value: \"[bB]\", description: \"[bB]\" },\n        peg$c198 = function(expr) {return [\"b\", \"b\"];},\n        peg$c199 = /^[fF]/,\n        peg$c200 = { type: \"class\", value: \"[fF]\", description: \"[fF]\" },\n        peg$c201 = function(expr) {return [\"f\", \"f\"];},\n        peg$c202 = /^[vV]/,\n        peg$c203 = { type: \"class\", value: \"[vV]\", description: \"[vV]\" },\n        peg$c204 = function(expr) {return [\"v\", \"v\"];},\n        peg$c205 = /^[tT]/,\n        peg$c206 = { type: \"class\", value: \"[tT]\", description: \"[tT]\" },\n        peg$c207 = function(expr) {return [\"t\", \"t\"];},\n        peg$c208 = /^[dD]/,\n        peg$c209 = { type: \"class\", value: \"[dD]\", description: \"[dD]\" },\n        peg$c210 = function(expr) {return [\"d\", \"d\"];},\n        peg$c211 = /^[sS]/,\n        peg$c212 = { type: \"class\", value: \"[sS]\", description: \"[sS]\" },\n        peg$c213 = function(expr) {return [\"s\", \"s\"];},\n        peg$c214 = /^[zZ]/,\n        peg$c215 = { type: \"class\", value: \"[zZ]\", description: \"[zZ]\" },\n        peg$c216 = function(expr) {return [\"z\", \"z\"];},\n        peg$c217 = /^[cC]/,\n        peg$c218 = { type: \"class\", value: \"[cC]\", description: \"[cC]\" },\n        peg$c219 = function(expr) {return [\"c\", \"c\"];},\n        peg$c220 = /^[jJ]/,\n        peg$c221 = { type: \"class\", value: \"[jJ]\", description: \"[jJ]\" },\n        peg$c222 = function(expr) {return [\"j\", \"j\"];},\n        peg$c223 = /^[gG]/,\n        peg$c224 = { type: \"class\", value: \"[gG]\", description: \"[gG]\" },\n        peg$c225 = function(expr) {return [\"g\", \"g\"];},\n        peg$c226 = /^[kK]/,\n        peg$c227 = { type: \"class\", value: \"[kK]\", description: \"[kK]\" },\n        peg$c228 = function(expr) {return [\"k\", \"k\"];},\n        peg$c229 = function(expr) {return _node(\"post_word\", expr);},\n        peg$c230 = function(expr) {return _node(\"spaces\", expr);},\n        peg$c231 = function(expr) {return _node(\"hesitation\", expr);},\n        peg$c232 = /^[\\n\\r]/,\n        peg$c233 = { type: \"class\", value: \"[\\\\n\\\\r]\", description: \"[\\\\n\\\\r]\" },\n        peg$c234 = function(expr) {return _node(\"hyphen\", expr);},\n        peg$c235 = /^[\\u2010\\u2014\\-]/,\n        peg$c236 = { type: \"class\", value: \"[\\\\u2010\\\\u2014\\\\-]\", description: \"[\\\\u2010\\\\u2014\\\\-]\" },\n        peg$c237 = function(expr) {return _node(\"hyphen_char\", expr);},\n        peg$c238 = /^['\\u2019`]/,\n        peg$c239 = { type: \"class\", value: \"['\\\\u2019`]\", description: \"['\\\\u2019`]\" },\n        peg$c240 = function(expr) {return _node(\"pause_char\", expr);},\n        peg$c241 = function(expr) {return _join(expr);},\n        peg$c242 = /^[0123456789]/,\n        peg$c243 = { type: \"class\", value: \"[0123456789]\", description: \"[0123456789]\" },\n        peg$c244 = function(expr) {return [\"digit\", expr];},\n        peg$c245 = function(expr) {return _node(\"EOF\", expr);},\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$cache = {},\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsetext() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 0,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_interjection();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parsefree_parenthetical();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_interjection();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsefree_parenthetical();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparagraphs();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsespaces();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseEOF();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c3(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraphs() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 1,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseparagraph();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        s6 = peg$parsePU_clause();\n        peg$silentFails--;\n        if (s6 !== peg$FAILED) {\n          peg$currPos = s5;\n          s5 = peg$c4;\n        } else {\n          s5 = peg$c0;\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseparagraph();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsePU_clause();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseparagraph();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c5(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 188 + 2,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePU_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparagraph_unit();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsePA_clause();\n          if (s7 === peg$FAILED) {\n            s7 = peg$parsePO_clause();\n          }\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseparagraph_unit();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsePA_clause();\n            if (s7 === peg$FAILED) {\n              s7 = peg$parsePO_clause();\n            }\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseparagraph_unit();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c6(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph_unit() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 3,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseparagraph_unit_erased();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseparagraph_unit_1();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c7(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph_unit_erased() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 4,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseparagraph_unit_1();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseCU_clause();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c8(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph_unit_1() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 5,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsedefinition();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsesentence();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c9(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsearguments_list() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 6,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parseKI_clause();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseGI_clause();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseKI_clause();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseGI_clause();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePI_clause();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c10(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedefinition() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 7,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedefined();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsePOI_clause_elidible();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c11(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedefined() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 8,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseGI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsefreeform_variable();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsepredicate_compound();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsepredicate_root();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c12(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesentence() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 9,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePA_clause_elidible();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsescope();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePAI_clause_elidible();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 10,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsearguments_list();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsescope_1();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_1() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 11,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsescope_sequence();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsescope_2();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c15(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_sequence() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 12,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsescope_sequence_item();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parseBU_clause();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsescope_sequence_item();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            s5 = peg$parseBU_clause();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsescope_sequence_item();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_sequence_item() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 13,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsescope_2();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c17(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_2() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 14,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsechaining();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c18(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsechaining() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 188 + 15,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsechaining_neg();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsechaining_unit();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsechaining_neg();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsechaining_unit();\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsechaining_neg() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 16,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechaining();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c20(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsechaining_unit() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 17,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsepredicate();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseve_scope();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c21(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseve_scope() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 18,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseve_scope_first();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parseve_scope_next();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parseve_scope_next();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseVEI_clause_elidible();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c22(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseve_scope_first() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 19,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseVE_clause();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c23(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseve_scope_next() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 20,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseFE_clause();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c24(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 21,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsepredicate_1();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsefree();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsefree();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c25(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_1() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 22,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parseSE_clause();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$currPos;\n        peg$silentFails++;\n        s6 = peg$parseSE_clause();\n        peg$silentFails--;\n        if (s6 === peg$FAILED) {\n          s5 = peg$c4;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$c0;\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseZI_clause();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parseSE_clause();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseSE_clause();\n          peg$silentFails--;\n          if (s6 === peg$FAILED) {\n            s5 = peg$c4;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseZI_clause();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsepredicate_2();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_2() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 23,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseBA_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseMI_clause();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsepredicate_quote();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsepredicate_variable();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsepredicate_scope();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parsepredicate_borrowing();\n                if (s1 === peg$FAILED) {\n                  s1 = peg$parsepredicate_root();\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$parsepredicate_number();\n                    if (s1 === peg$FAILED) {\n                      s1 = peg$parsepredicate_compound();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c27(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_root() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 24,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseroot();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c28(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_number() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 25,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c29(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_compound() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 26,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecompound();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c30(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_borrowing() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 27,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseborrowing_group();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c31(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_scope() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 28,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePE_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsescope();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePEI_clause_elidible();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c32(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_quote() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 29,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsegrammatical_quote();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseone_word_quote();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseforeign_quote();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c33(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsegrammatical_quote() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 30,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseCA_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetext();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCAI_clause();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseone_word_quote() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 31,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseCE_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenative_word();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parsecompound();\n            if (s4 === peg$FAILED) {\n              s4 = peg$parseborrowing();\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c35(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 188 + 32,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseCO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseforeign_quote_open();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsespace_char();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseforeign_quote_content();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsepause_char();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseforeign_quote_close();\n                  if (s8 !== peg$FAILED) {\n                    s2 = [s2, s3, s4, s5, s6, s7, s8];\n                    s1 = s2;\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c36(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_content() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 33,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$currPos;\n      s5 = peg$parsepause_char();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parseforeign_quote_close();\n        if (s6 !== peg$FAILED) {\n          s5 = [s5, s6];\n          s4 = s5;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$c0;\n      }\n      peg$silentFails--;\n      if (s4 === peg$FAILED) {\n        s3 = peg$c4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parsepause_char();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseforeign_quote_close();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c37); }\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c38(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 34,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parseTI_clause();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseTI_clause();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBE_clause_elidible();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c39(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseborrowing_group() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 35,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsespaces();\n      if (s4 === peg$FAILED) {\n        s4 = peg$c2;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseborrowing();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsespaces();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseborrowing();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBE_clause_elidible();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c40(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_variable() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 36,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBO_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseKI_clause();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseGI_clause();\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            s4 = peg$parsespaces();\n            if (s4 === peg$FAILED) {\n              s4 = peg$c2;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsefreeform_variable();\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c0;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c41(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseoverride() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 37,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDU_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsepredicate_1();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c42(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 38,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsefree_metadata();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsefree_parenthetical();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsefree_subscript();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsefree_interjection();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c43(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_metadata() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 39,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseDA_clause();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c44(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_subscript() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 40,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDI_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c45(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_parenthetical() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 41,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetext();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseDOI_clause();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c46(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_interjection() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 42,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDE_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsepredicate_1();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c47(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBA_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 43,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBA();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c48(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 44,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBE();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c49(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBI_clause() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 45,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBI();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsefree();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsefree();\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c50(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBO_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 46,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBO();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c51(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBU_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 47,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBU();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c52(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDA_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 48,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDA();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c53(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDE_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 49,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDE();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c54(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 50,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c55(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDO_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 51,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDO();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c56(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDOI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 52,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDOI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c57(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDU_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 53,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDU();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c58(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseSE_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 54,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseSE();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseoverride();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c59(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseZI_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 55,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseZI();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseoverride();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c60(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVE_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 56,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseVE();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseoverride();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c61(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseFE_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 57,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseFE();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseoverride();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c62(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVEI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 58,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseVEI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c63(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseGI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 59,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseGI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c64(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseKI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 60,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseKI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c65(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseMI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 61,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseMI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c66(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA_clause() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 62,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePA();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsefree();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsefree();\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c67(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePAI_clause() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 63,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePAI();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsefree();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsefree();\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c68(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePE_clause() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 64,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePE();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsefree();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsefree();\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c69(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePEI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 65,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePEI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c70(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 66,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c71(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePO_clause() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 67,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePO();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsefree();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsefree();\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c72(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePOI_clause() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 68,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePOI();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsefree();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsefree();\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c73(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePU_clause() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 69,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePU();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsefree();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsefree();\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c74(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseTI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 70,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseTI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c75(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCA_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 71,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseCA();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c76(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCAI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 72,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseCAI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c77(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCE_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 73,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseCE();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c78(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCO_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 74,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseCO();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c79(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCU_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 75,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseCU();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c80(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 76,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseBE_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c81(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 77,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePA_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c82(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePAI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 78,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePAI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c83(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePEI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 79,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePEI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c84(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePOI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 80,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePOI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c85(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVEI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 81,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseVEI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c86(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 82,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c87(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 83,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c88(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 84,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsei();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c89(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBO() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 85,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c90(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBU() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 86,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c91(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCA() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 188 + 87,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parseCAI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsec();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsea();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehieaou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c92(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCAI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 88,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsec();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c93(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 89,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsec();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c94(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCO() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 90,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsec();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseo();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c95(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCU() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 91,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsec();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseu();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c96(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDA() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 92,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsea();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c97(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 93,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c98(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 94,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsei();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c99(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDO() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 95,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c100(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDOI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 96,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c101(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDU() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 97,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseu();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c102(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseFE() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 98,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsef();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c103(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseGI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 99,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseg();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c104(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseKI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 100,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsek();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c105(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseMI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 101,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsem();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c106(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 188 + 102,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parsePAI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsep();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsea();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehieaou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c107(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePAI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 103,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c108(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePE() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 104,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsee();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c109(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePEI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 105,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsee();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c110(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 106,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsei();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c111(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePO() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 188 + 107,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parsePOI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsep();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parseo();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehieaou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c112(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePOI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 108,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c113(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePU() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 109,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c114(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseSE() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 110,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parses();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c115(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseTI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 111,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parset();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsedigit();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = peg$c4;\n          } else {\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c116(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVE() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 188 + 112,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parseVEI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsev();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c117(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVEI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 113,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsev();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsee();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c118(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseZI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 114,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsez();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c119(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_open() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 115,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenative_word();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c120(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_word() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 116,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$parsepause_char();\n      peg$silentFails--;\n      if (s4 === peg$FAILED) {\n        s3 = peg$c4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsepause_char();\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c37); }\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = [s3, s4];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c121(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_close() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 188 + 117,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenative_word();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = peg$currPos;\n        s2 = peg$c122(s1);\n        if (s2) {\n          s2 = peg$c4;\n        } else {\n          s2 = peg$c0;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c123(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 118,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecompound_2();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsecompound_3();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsecompound_n();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c124(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_2() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 119,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsee();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecompound_word();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound_word();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c125(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_3() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 120,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsea();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecompound_word();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound_word();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecompound_word();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c126(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_n() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 121,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseo();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        s6 = peg$parsecompound_n_end();\n        peg$silentFails--;\n        if (s6 === peg$FAILED) {\n          s5 = peg$c4;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$c0;\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecompound_word();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsecompound_n_end();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecompound_word();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound_n_end();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c127(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_n_end() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 122,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseo();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsespaces();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c128(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_word() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 123,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseborrowing();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsenative_word();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c129(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefreeform_variable() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 124,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsei();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsespaces();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsei();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parsehyphen();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsei();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsefreeform_content();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsefreeform_end();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c130(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseborrowing() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 125,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseu();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsespaces();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parsehyphen();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseu();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsefreeform_content();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsefreeform_end();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c131(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefreeform_content() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 188 + 126,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseinitial_pair();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseconsonant();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseh();\n        }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehieaou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parseconsonant_cluster();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsehieaou();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$parseconsonant_cluster();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehieaou();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c132(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefreeform_end() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 127,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsepause_char();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsespace_char();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOF();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c133(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenative_word() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 128,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseroot();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseparticle();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c134(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparticle() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 129,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsesonorant();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparticle_1();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c135(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 130,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsesonorant();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseroot_1();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseroot_2();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parseroot_3();\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c136(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparticle_1() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 131,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehieaou();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsemedial_pair();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c137(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_1() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 188 + 132,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehieaou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parsehyphen();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsemedial_pair();\n            if (s7 === peg$FAILED) {\n              s7 = peg$parsesonorant();\n            }\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsehieaou();\n              if (s8 !== peg$FAILED) {\n                s6 = [s6, s7, s8];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$parsehyphen();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsemedial_pair();\n                if (s7 === peg$FAILED) {\n                  s7 = peg$parsesonorant();\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsehieaou();\n                  if (s8 !== peg$FAILED) {\n                    s6 = [s6, s7, s8];\n                    s5 = s6;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$c0;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            }\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c138(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_2() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 133,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehieaou();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesonorant();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c139(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_3() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 188 + 134,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseinitial_pair();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehieaou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parsehyphen();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsemedial_pair();\n            if (s7 === peg$FAILED) {\n              s7 = peg$parsesonorant();\n            }\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsehieaou();\n              if (s8 !== peg$FAILED) {\n                s6 = [s6, s7, s8];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$parsehyphen();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsemedial_pair();\n              if (s7 === peg$FAILED) {\n                s7 = peg$parsesonorant();\n              }\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parsehieaou();\n                if (s8 !== peg$FAILED) {\n                  s6 = [s6, s7, s8];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$c0;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c140(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehieaou() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 188 + 135,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseieaou();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parsehyphen();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseh();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseieaou();\n            if (s7 !== peg$FAILED) {\n              s5 = [s5, s6, s7];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$parsehyphen();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseh();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseieaou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c141(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseieaou() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 136,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsevowel();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parsehyphen();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsevowel();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$parsehyphen();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsevowel();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c142(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant_cluster() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 137,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant_cluster_1();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseconsonant_cluster_2();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseconsonant();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c143(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant_cluster_1() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 138,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsehyphen();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsemedial_pair();\n        peg$silentFails--;\n        if (s4 !== peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$c4;\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseconsonant();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseinitial_pair();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsehyphen();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsemedial_pair();\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c144(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant_cluster_2() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 139,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsesonorant();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehyphen();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseinitial_pair();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parseconsonant();\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsesonorant();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsehyphen();\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c145(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemedial_pair() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 188 + 140,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseinitial_pair();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsemedial_patterns();\n        peg$silentFails--;\n        if (s4 !== peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$c4;\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseconsonant();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseconsonant();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$parseconsonant();\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = peg$c4;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$c0;\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c146(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemedial_patterns() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 141,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsemedial_n();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsemedial_fv();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsemedial_plosive();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c147(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemedial_n() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 142,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsem();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseliquid();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsen();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsen();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseliquid();\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c148(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemedial_fv() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 143,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsef();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsev();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseplosive();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsesibilant();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsem();\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c149(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemedial_plosive() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 144,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseplosive();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsef();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsev();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parseplosive();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsem();\n            }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c150(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinitial_pair() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 145,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseinitial();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseconsonant();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseconsonant();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseconsonant();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c151(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinitial() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 146,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      s3 = peg$parseplosive();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parsef();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsev();\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsesibilant();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parsesibilant();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseother();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s3 = [s3, s4, s5];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseconsonant();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c152(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseother() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 147,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseb();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsen();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parset();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsed();\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsen();\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parsel();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = peg$c4;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n            if (s4 !== peg$FAILED) {\n              s2 = [s2, s3, s4];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsev();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsef();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsek();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parseg();\n                if (s1 === peg$FAILED) {\n                  s1 = peg$parsem();\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$currPos;\n                    s2 = peg$parsen();\n                    if (s2 !== peg$FAILED) {\n                      s3 = peg$currPos;\n                      peg$silentFails++;\n                      s4 = peg$parseliquid();\n                      peg$silentFails--;\n                      if (s4 === peg$FAILED) {\n                        s3 = peg$c4;\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$c0;\n                      }\n                      if (s3 !== peg$FAILED) {\n                        s2 = [s2, s3];\n                        s1 = s2;\n                      } else {\n                        peg$currPos = s1;\n                        s1 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s1;\n                      s1 = peg$c0;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c153(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseplosive() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 148,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parset();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsed();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsek();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseg();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsep();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parseb();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c154(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesibilant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 149,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsec();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parses();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsej();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsez();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c155(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesonorant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 150,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsen();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parser();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsel();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c156(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 151,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsevoiced();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseunvoiced();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseliquid();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsenasal();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c157(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenasal() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 152,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsem();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsen();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c158(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseliquid() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 153,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsel();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parser();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c159(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevoiced() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 154,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseb();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsed();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseg();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsev();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsez();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parsej();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c160(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunvoiced() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 155,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsep();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parset();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsek();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsef();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parses();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parsec();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c161(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevowel() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 156,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsei();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsee();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsea();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseo();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parseu();\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c162(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsei() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 157,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c163.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c164); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c163.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c164); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsei();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c165(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsee() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 158,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c166.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c167); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c166.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c167); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsee();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c168(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsea() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 159,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c169.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c170); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c169.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c170); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsea();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c171(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseo() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 160,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c172.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c173); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c172.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c173); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseo();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c174(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseu() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 161,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c175.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c176); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c175.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c176); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseu();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c177(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseh() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 162,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c178.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c179); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c178.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c179); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseh();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c180(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsen() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 163,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c181.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c182); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c181.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c182); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsen();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c183(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parser() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 164,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c184.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c185); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c184.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c185); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parser();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c186(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsel() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 165,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c187.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c188); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c187.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c188); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsel();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c189(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsem() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 166,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c190.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c191); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c190.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c191); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsem();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c192(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsep() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 167,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c193.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c194); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c193.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c194); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsep();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c195(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseb() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 168,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c196.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c197); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c196.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c197); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseb();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c198(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsef() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 169,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c199.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c200); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c199.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c200); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsef();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c201(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsev() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 170,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c202.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c203); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c202.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c203); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsev();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c204(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parset() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 171,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c205.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c206); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c205.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c206); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parset();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c207(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsed() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 172,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c208.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c209); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c208.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c209); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsed();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c210(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parses() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 173,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c211.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c212); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c211.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c212); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parses();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsec();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsevoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c213(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsez() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 174,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c214.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c215); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c214.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c215); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsez();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsej();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseunvoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c216(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsec() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 175,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c217.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c218); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c217.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c218); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsec();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parses();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsevoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c219(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsej() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 188 + 176,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c220.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c221); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c220.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c221); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsej();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsez();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseunvoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c222(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseg() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 177,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c223.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c224); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c223.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c224); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseg();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c225(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsek() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 178,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c226.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c227); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c226.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c227); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsek();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c228(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepost_word() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 179,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsepause_char();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsevowel();\n        peg$silentFails--;\n        if (s4 !== peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$c4;\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        peg$silentFails++;\n        s3 = peg$parsesonorant();\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = peg$c4;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseconsonant();\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = peg$c4;\n          } else {\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsespaces();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c229(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsespaces() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 188 + 180,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsespace_char();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsespace_char();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehesitation();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsepause_char();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsevowel();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsepause_char();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsevowel();\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = peg$c4;\n          } else {\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOF();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c230(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehesitation() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 188 + 181,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$parsen();\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsespace_char();\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsespace_char();\n          }\n        } else {\n          s4 = peg$c0;\n        }\n        if (s4 === peg$FAILED) {\n          s4 = peg$parseEOF();\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$parsen();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parsespace_char();\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$parsespace_char();\n              }\n            } else {\n              s4 = peg$c0;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = peg$parseEOF();\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = [s3, s4];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c231(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehyphen() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 182,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsehyphen_char();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c232.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c233); }\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c232.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c233); }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c234(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehyphen_char() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 183,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c235.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c236); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c237(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepause_char() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 188 + 184,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c238.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c239); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsepause_char();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c240(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsespace_char() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 188 + 185,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsepause_char();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parsedigit();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsehyphen_char();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsevowel();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parseconsonant();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parseh();\n              }\n            }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c241(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedigit() {\n      var s0, s1;\n\n      var key    = peg$currPos * 188 + 186,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c242.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c243); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c244(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseEOF() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 188 + 187,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c37); }\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = peg$c4;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c245(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n      var _g_foreign_quote_delim;\n\n      function _join(arg) {\n        if (typeof(arg) == \"string\")\n          return arg;\n        else if (arg) {\n          var ret = \"\";\n          for (var v in arg) { if (arg[v]) ret += _join(arg[v]); }\n          return ret;\n        }\n      }\n\n      function _node_empty(label, arg) {\n        var ret = [];\n        if (label) ret.push(label);\n        if (arg && typeof arg == \"object\" && typeof arg[0] == \"string\" && arg[0]) {\n          ret.push( arg );\n          return ret;\n        }\n        if (!arg)\n        {\n          return ret;\n        }\n        return _node_int(label, arg);\n      }\n\n      function _node_int(label, arg) {\n        if (typeof arg == \"string\")\n          return arg;\n        if (!arg) arg = [];\n        var ret = [];\n        if (label) ret.push(label);\n        for (var v in arg) {\n          if (arg[v] && arg[v].length != 0)\n            ret.push( _node_int( null, arg[v] ) );\n        }\n        return ret;\n      }\n\n      function _node2(label, arg1, arg2) {\n        return [label].concat(_node_empty(arg1)).concat(_node_empty(arg2));\n      }\n\n      function _node(label, arg) {\n        var _n = _node_empty(label, arg);\n        return (_n.length == 1 && label) ? [] : _n;\n      }\n      var _node_nonempty = _node;\n\n      // === Functions for faking left recursion === //\n\n      function _flatten_node(a) {\n        // Flatten nameless nodes\n        // e.g. [Name1, [[Name2, X], [Name3, Y]]] --> [Name1, [Name2, X], [Name3, Y]]\n        if (is_array(a)) {\n          var i = 0;\n          while (i < a.length) {\n            if (!is_array(a[i])) i++;\n            else if (a[i].length === 0) // Removing []s\n              a = a.slice(0, i).concat(a.slice(i + 1));\n            else if (is_array(a[i][0]))\n              a = a.slice(0, i).concat(a[i], a.slice(i + 1));\n            else i++;\n          }\n        }\n        return a;\n      }\n\n      function _group_leftwise(arr) {\n        if (!is_array(arr)) return [];\n        else if (arr.length <= 2) return arr;\n        else return [_group_leftwise(arr.slice(0, -1)), arr[arr.length - 1]];\n      }\n\n      // \"_lg\" for \"Leftwise Grouping\".\n      function _node_lg(label, arg) {\n        return _node(label, _group_leftwise(_flatten_node(arg)));\n      }\n\n      function _node_lg2(label, arg) {\n        if (is_array(arg) && arg.length == 2)\n          arg = arg[0].concat(arg[1]);\n        return _node(label, _group_leftwise(arg));\n      }\n\n      // === Foreign words functions === //\n\n      function _assign_foreign_quote_delim(w) {\n        if (is_array(w)) w = join_expr(w);\n        else if (!is_string(w)) throw \"ERROR: foreign_quote word is of type \" + typeof w;\n        w = w.toLowerCase().replace(/,/gm,\"\").replace(/h/g, \"'\");\n        _g_foreign_quote_delim = w;\n        return;\n      }\n\n      function _is_foreign_quote_delim(w) {\n        if (is_array(w)) w = join_expr(w);\n        else if (!is_string(w)) throw \"ERROR: foreign_quote word is of type \" + typeof w;\n        /* Keeping spaces in the parse tree seems to result in the absorbtion of\n           spaces into the closing delimiter candidate, so we'll remove any space\n           character from our input. */\n        w = w.replace(/[.\\t\\n\\r?!\\u0020]/g, \"\");\n        w = w.toLowerCase().replace(/,/gm,\"\").replace(/h/g, \"'\");\n        return w === _g_foreign_quote_delim;\n      }\n\n      function join_expr(n) {\n        if (!is_array(n) || n.length < 1) return \"\";\n        var s = \"\";\n        var i = is_array(n[0]) ? 0 : 1;\n        while (i < n.length) {\n          s += is_string(n[i]) ? n[i] : join_expr(n[i]);\n          i++;\n        }\n        return s;\n      }\n\n      function is_string(v) {\n        // return $.type(v) === \"string\";\n        return Object.prototype.toString.call(v) === '[object String]';\n      }\n\n      function is_array(v) {\n        // return $.type(v) === \"array\";\n        return Object.prototype.toString.call(v) === '[object Array]';\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})()\nmodule.exports.camxes = camxes;\n\n\n//# sourceURL=webpack://bundle/./grammar/eberban.js?");

/***/ }),

/***/ "../dictionary/en.yaml":
/*!*****************************!*\
  !*** ../dictionary/en.yaml ***!
  \*****************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"0\":{\"family\":\"TI\",\"long\":\"Digit 0\",\"short\":\"te\"},\"1\":{\"family\":\"TI\",\"long\":\"Digit 1\",\"short\":\"ta\"},\"2\":{\"family\":\"TI\",\"long\":\"Digit 2\",\"short\":\"to\"},\"3\":{\"family\":\"TI\",\"long\":\"Digit 3\",\"short\":\"tu\"},\"4\":{\"family\":\"TI\",\"long\":\"Digit 4\",\"short\":\"tei\"},\"5\":{\"family\":\"TI\",\"long\":\"Digit 5\",\"short\":\"tai\"},\"6\":{\"family\":\"TI\",\"long\":\"Digit 6\",\"short\":\"toi\"},\"7\":{\"family\":\"TI\",\"long\":\"Digit 7\",\"short\":\"tui\"},\"8\":{\"family\":\"TI\",\"long\":\"Digit 8\",\"short\":\"tie\"},\"9\":{\"family\":\"TI\",\"long\":\"Digit 9\",\"short\":\"tia\"},\"_cardinal\":{\"long\":\"(Ec) is (a group of) [number] things satisfying [A1].\"},\"_number\":{\"long\":\"(En) is the (abstract) number [number] times [An] (default: 1).\"},\"mi\":{\"family\":\"MI\",\"long\":\"(Ed) is I/me/a speaker/author.\",\"short\":\"me\"},\"mo\":{\"family\":\"MI\",\"long\":\"(Ed) is you, a listener.\",\"short\":\"you\"},\"mio\":{\"family\":\"MI\",\"long\":\"(Ed) is I/a speaker/author or you, a listener.\",\"short\":\"inclusive we\"},\"mie\":{\"family\":\"MI\",\"long\":\"(Ed) is I/a speaker/author or someone, neither a speaker or listener.\",\"short\":\"exclusive we\"},\"ma\":{\"family\":\"MI\",\"long\":\"(Ed) exists.\\\\n\\\\nPerforms no restrictions over the existential variable.\\\\nHowever, it can be useful to more precisely control the scope of existential\\\\nclaims, or perform tricks using the chaining system.\\\\n\",\"short\":\"exists\"},\"mau\":{\"family\":\"MI\",\"long\":\"(Ed) is not bound outside of this scope.\\\\n\\\\nCan be used with {sen} to define the default meaning of a unbound parameter.\\\\nUse {zoi} for predicate places.\\\\n\",\"short\":\"unbound\"},\"mai\":{\"family\":\"MI\",\"long\":\"(Ed) is indefinite specific.\\\\nThe speaker has a specific individual in mind, but the listener is not\\\\nexpected to know which one.\\\\n\",\"short\":\"a\"},\"mao\":{\"family\":\"MI\",\"long\":\"(Ed) is definite specific.\\\\nThe speaker has a specific individual in mind and the listener is expected\\\\nto know which one from context.\\\\n\",\"short\":\"the\"},\"me\":{\"family\":\"MI\",\"long\":\"(Ed) is someone, neither a speaker or listener.\",\"short\":\"other\"},\"mei\":{\"family\":\"MI\",\"long\":\"(Ed) is this here, near a speaker.\",\"short\":\"this\"},\"meo\":{\"family\":\"MI\",\"long\":\"(Ed) is that here, near a listener.\",\"short\":\"that\"},\"meu\":{\"family\":\"MI\",\"long\":\"(Ed) is that yonder, far from speaker and listener.\",\"short\":\"that yonder\"},\"mua\":{\"family\":\"MI\",\"long\":\"States the last/previous proposition.\",\"short\":\"last prop\"},\"mue\":{\"family\":\"MI\",\"long\":\"States the proposition (0-ary scope) in which this one is embeded.\",\"short\":\"outer prop\"},\"mui\":{\"family\":\"MI\",\"long\":\"States the current proposition.\",\"short\":\"current prop\"},\"muo\":{\"family\":\"MI\",\"long\":\"States the next proposition.\",\"short\":\"next prop\"},\"ba\":{\"family\":\"BA\",\"long\":\"Inline argument marker.\",\"short\":\"[inline arg]\"},\"te\":{\"family\":\"TI\",\"long\":\"Digit 0\",\"short\":\"0\",\"tags\":[\"digit\",\"number\"]},\"ta\":{\"family\":\"TI\",\"long\":\"Digit 1\",\"short\":\"1\",\"tags\":[\"digit\",\"number\"]},\"to\":{\"family\":\"TI\",\"long\":\"Digit 2\",\"short\":\"2\",\"tags\":[\"digit\",\"number\"]},\"tu\":{\"family\":\"TI\",\"long\":\"Digit 3\",\"short\":\"3\",\"tags\":[\"digit\",\"number\"]},\"tei\":{\"family\":\"TI\",\"long\":\"Digit 4\",\"short\":\"4\",\"tags\":[\"digit\",\"number\"]},\"tai\":{\"family\":\"TI\",\"long\":\"Digit 5\",\"short\":\"5\",\"tags\":[\"digit\",\"number\"]},\"toi\":{\"family\":\"TI\",\"long\":\"Digit 6\",\"short\":\"6\",\"tags\":[\"digit\",\"number\"]},\"tui\":{\"family\":\"TI\",\"long\":\"Digit 7\",\"short\":\"7\",\"tags\":[\"digit\",\"number\"]},\"tie\":{\"family\":\"TI\",\"long\":\"Digit 8\",\"short\":\"8\",\"tags\":[\"digit\",\"number\"]},\"tia\":{\"family\":\"TI\",\"long\":\"Digit 9\",\"short\":\"9\",\"tags\":[\"digit\",\"number\"]},\"tio\":{\"family\":\"TI\",\"long\":\"Digit /A (10)\",\"short\":\"A\",\"tags\":[\"digit\",\"number\"]},\"tiu\":{\"family\":\"TI\",\"long\":\"Digit /B (11)\",\"short\":\"B\",\"tags\":[\"digit\",\"number\"]},\"teie\":{\"family\":\"TI\",\"long\":\"Digit C (12)\",\"short\":\"C\",\"tags\":[\"digit\",\"number\"]},\"teia\":{\"family\":\"TI\",\"long\":\"Digit D (13)\",\"short\":\"D\",\"tags\":[\"digit\",\"number\"]},\"teio\":{\"family\":\"TI\",\"long\":\"Digit E (14)\",\"short\":\"E\",\"tags\":[\"digit\",\"number\"]},\"teiu\":{\"family\":\"TI\",\"long\":\"Digit F (15)\",\"short\":\"F\",\"tags\":[\"digit\",\"number\"]},\"ti\":{\"family\":\"TI\",\"long\":\"Decimal separator\",\"short\":\".\",\"tags\":[\"separator\",\"number\"]},\"tiha\":{\"family\":\"TI\",\"long\":\"<base . number> separator\",\"short\":\"base\",\"tags\":[\"separator\",\"number\"]},\"tihe\":{\"family\":\"TI\",\"long\":\"<precise . approximation> separator\",\"short\":\"approx\",\"tags\":[\"separator\",\"number\"]},\"tihi\":{\"family\":\"TI\",\"long\":\"<precise . repeating part> separator\",\"short\":\"repeating\",\"tags\":[\"separator\",\"number\"]},\"tiho\":{\"family\":\"TI\",\"long\":\"<numerator . denominator> separator\",\"short\":\"fraction\",\"tags\":[\"separator\",\"number\"]},\"tahe\":{\"family\":\"TI\",\"long\":\"10^3 separator (kilo)\",\"short\":\"10^3\",\"tags\":[\"separator\",\"number\"]},\"taha\":{\"family\":\"TI\",\"long\":\"10^6 separator (mega)\",\"short\":\"10^6\",\"tags\":[\"separator\",\"number\"]},\"taho\":{\"family\":\"TI\",\"long\":\"10^9 separator (giga)\",\"short\":\"10^9\",\"tags\":[\"separator\",\"number\"]},\"tahu\":{\"family\":\"TI\",\"long\":\"10^12 separator (tera)\",\"short\":\"10^12\",\"tags\":[\"separator\",\"number\"]},\"tahei\":{\"family\":\"TI\",\"long\":\"10^15 separator (peta)\",\"short\":\"10^15\",\"tags\":[\"separator\",\"number\"]},\"tahai\":{\"family\":\"TI\",\"long\":\"10^18 separator (exa)\",\"short\":\"10^18\",\"tags\":[\"separator\",\"number\"]},\"tahoi\":{\"family\":\"TI\",\"long\":\"10^21 separator (zetta)\",\"short\":\"10^21\",\"tags\":[\"separator\",\"number\"]},\"tahui\":{\"family\":\"TI\",\"long\":\"10^24 separator (yotta)\",\"short\":\"10^24\",\"tags\":[\"separator\",\"number\"]},\"tea\":{\"family\":\"TI\",\"long\":\"negative sign\",\"short\":\"-\",\"tags\":[\"number\"]},\"tehe\":{\"family\":\"TI\",\"long\":\"Vector component 0\",\"short\":\"vec 0:\",\"tags\":[\"separator\",\"number\",\"vector\"]},\"teha\":{\"family\":\"TI\",\"long\":\"Vector component 1\",\"short\":\"vec 1:\",\"tags\":[\"separator\",\"number\",\"vector\"]},\"teho\":{\"family\":\"TI\",\"long\":\"Vector component 2\",\"short\":\"vec 2:\",\"tags\":[\"separator\",\"number\",\"vector\"]},\"tehu\":{\"family\":\"TI\",\"long\":\"Vector component 3\",\"short\":\"vec 3:\",\"tags\":[\"separator\",\"number\",\"vector\"]},\"tehei\":{\"family\":\"TI\",\"long\":\"Vector component 4\",\"short\":\"vec 4:\",\"tags\":[\"separator\",\"number\",\"vector\"]},\"tehai\":{\"family\":\"TI\",\"long\":\"Vector component 5\",\"short\":\"vec 5:\",\"tags\":[\"separator\",\"number\",\"vector\"]},\"tehoi\":{\"family\":\"TI\",\"long\":\"Vector component 6\",\"short\":\"vec 6:\",\"tags\":[\"separator\",\"number\",\"vector\"]},\"tehui\":{\"family\":\"TI\",\"long\":\"Vector component 7\",\"short\":\"vec 7:\",\"tags\":[\"separator\",\"number\",\"vector\"]},\"ca\":{\"family\":\"CA\",\"long\":\"Starts grammatically correct eberban quote. (Ed) is text [quote].\",\"short\":\"\"},\"cai\":{\"family\":\"CAI\",\"long\":\"Ends grammatically correct eberban quote.\",\"short\":\"\",\"tags\":[\"terminator\"]},\"ce\":{\"family\":\"CE\",\"long\":\"Quote next word. (Ed) is word [word].\",\"short\":\"[word]\"},\"cei\":{\"family\":\"CE\",\"long\":\"(Ed) is the family of word [word].\",\"short\":\"[family]\"},\"ceu\":{\"family\":\"CE\",\"long\":\"Provides a predicate describing the meaning of the following particle.\",\"short\":\"[meaning]\"},\"co\":{\"family\":\"CO\",\"long\":\"(Ed) is a quote of an arbitrary string of space separated \\\\\"words\\\\\".\",\"short\":\"\"},\"cu\":{\"family\":\"CU\",\"long\":\"Erase the currently sentence/defintion.\\\\nUsed when a mistake is made to redo the sentence/definition.\\\\\"\\\\n\",\"short\":\"[erased]\"},\"fe\":{\"family\":\"FE\",\"long\":\"Switch to the E place of the predicate before the current VE-scope.\",\"short\":\"switch-E\"},\"fa\":{\"family\":\"FE\",\"long\":\"Switch to the A place of the predicate before the current VE-scope.\",\"short\":\"switch-A\"},\"fo\":{\"family\":\"FE\",\"long\":\"Switch to the O place of the predicate before the current VE-scope.\",\"short\":\"switch-O\"},\"fu\":{\"family\":\"FE\",\"long\":\"Switch to the U place of the predicate before the current VE-scope.\",\"short\":\"switch-U\"},\"fie\":{\"family\":\"FE\",\"long\":\"Switch to a reference of the E place of the predicate before the current VE-scope.\\\\nThis reference is an individual representing the content of the place.\\\\n\",\"short\":\"switch-E-ref\"},\"fia\":{\"family\":\"FE\",\"long\":\"Switch to a reference of the A place of the predicate before the current VE-scope.\\\\nThis reference is an individual representing the content of the place.\\\\n\",\"short\":\"switch-A-ref\"},\"fio\":{\"family\":\"FE\",\"long\":\"Switch to a reference of the O place of the predicate before the current VE-scope.\\\\nThis reference is an individual representing the content of the place.\\\\n\",\"short\":\"switch-O-ref\"},\"fiu\":{\"family\":\"FE\",\"long\":\"Switch to a reference of the U place of the predicate before the current VE-scope.\\\\nThis reference is an individual representing the content of the place.\\\\n\",\"short\":\"switch-U-ref\"},\"fua\":{\"family\":\"FE\",\"long\":\"Switch to the same place as the previous FE/VE.\",\"short\":\"switch-same\"},\"fue\":{\"family\":\"FE\",\"long\":\"Switch to the next place relative to the previous FE/VE.\",\"short\":\"switch-next\"},\"ve\":{\"family\":\"VE\",\"long\":\"Switch to the E place of the predicate word before it, and start a VE-scope.\",\"short\":\" switch-E\"},\"va\":{\"family\":\"VE\",\"long\":\"Switch to the A place of the predicate word before it, and start a VE-scope.\",\"short\":\" switch-A\"},\"vo\":{\"family\":\"VE\",\"long\":\"Switch to the O place of the predicate word before it, and start a VE-scope.\",\"short\":\" switch-O\"},\"vu\":{\"family\":\"VE\",\"long\":\"Switch to the U place of the predicate word before it, and start a VE-scope.\",\"short\":\" switch-U\"},\"vie\":{\"family\":\"VE\",\"long\":\"Switch to a reference of the E place of the predicate word before it, and start a VE-scope.  \\\\nThis reference is an individual representing the content of the place.\\\\n\",\"short\":\" switch-E-ref\"},\"via\":{\"family\":\"VE\",\"long\":\"Switch to a reference of the A place of the predicate word before it, and start a VE-scope.  \\\\nThis reference is an individual representing the content of the place.\\\\n\",\"short\":\" switch-A-ref\"},\"vio\":{\"family\":\"VE\",\"long\":\"Switch to a reference of the O place of the predicate word before it, and start a VE-scope.  \\\\nThis reference is an individual representing the content of the place.\\\\n\",\"short\":\" switch-O-ref\"},\"viu\":{\"family\":\"VE\",\"long\":\"Switch to a reference of the U place of the predicate word before it, and start a VE-scope.  \\\\nThis reference is an individual representing the content of the place.\\\\n\",\"short\":\" switch-U-ref\"},\"vei\":{\"family\":\"VEI\",\"long\":\"Close the current VE-scope.\",\"short\":\"\",\"tags\":[\"terminator\",\"elidable\"]},\"se\":{\"family\":\"SE\",\"long\":\"Bind E place and disable switching.\",\"short\":\"<EE>\"},\"sa\":{\"family\":\"SE\",\"long\":\"Bind A place and disable switching.\",\"short\":\"<AA>\"},\"so\":{\"family\":\"SE\",\"long\":\"Bind O place and disable switching.\",\"short\":\"<OO>\"},\"su\":{\"family\":\"SE\",\"long\":\"Bind U place and disable switching.\",\"short\":\"<II>\"},\"sea\":{\"family\":\"SE\",\"long\":\"Bind E place then switch to the A place.\",\"short\":\"<EA>\"},\"seo\":{\"family\":\"SE\",\"long\":\"Bind E place then switch to the O place.\",\"short\":\"<EO>\"},\"seu\":{\"family\":\"SE\",\"long\":\"Bind E place then switch to the U place.\",\"short\":\"<EU>\"},\"sae\":{\"family\":\"SE\",\"long\":\"Bind A place then switch to the E place.\",\"short\":\"<AE>\"},\"sao\":{\"family\":\"SE\",\"long\":\"Bind A place then switch to the O place.\",\"short\":\"<AO>\"},\"sau\":{\"family\":\"SE\",\"long\":\"Bind A place then switch to the U place.\",\"short\":\"<AU>\"},\"soe\":{\"family\":\"SE\",\"long\":\"Bind O place then switch to the E place.\",\"short\":\"<OE>\"},\"soa\":{\"family\":\"SE\",\"long\":\"Bind O place then switch to the A place.\",\"short\":\"<OA>\"},\"sou\":{\"family\":\"SE\",\"long\":\"Bind O place then switch to the U place.\",\"short\":\"<OU>\"},\"sue\":{\"family\":\"SE\",\"long\":\"Bind U place then switch to the E place.\",\"short\":\"<UE>\"},\"sua\":{\"family\":\"SE\",\"long\":\"Bind U place then switch to the A place.\",\"short\":\"<UA>\"},\"suo\":{\"family\":\"SE\",\"long\":\"Bind U place then switch to the O place.\",\"short\":\"<UO>\"},\"za\":{\"family\":\"ZI\",\"long\":\"(Ec) is named [predicate-(E)].\",\"short\":\"named\"},\"ze\":{\"family\":\"ZI\",\"long\":\"Use the same instance and variables of the following unit instead of a new one.\",\"short\":\"same\"},\"zi\":{\"family\":\"ZI\",\"long\":\"Narrow-scope negation : negates the predicate unit but not the existential variables it creates.\\\\nThere exist e, a,... such that unit(e, a, ...) is false.\\\\n\",\"short\":\"non-\",\"tags\":[\"negation\"]},\"zo\":{\"family\":\"ZI\",\"long\":\"(Ec) is something referred to by [predicate-E].\",\"short\":\"deref\"},\"zoi\":{\"family\":\"ZI\",\"long\":\"(Ec) is a reference/symbol refering to [predicate].\",\"short\":\"ref\"},\"pa\":{\"family\":\"PA\",\"long\":\"Starts an assertive sentence, that can be believed or disbelieved, and is either true or false.\",\"short\":\"[assertion]\"},\"pae\":{\"family\":\"PA\",\"long\":\"Starts an vocative. Defines the listener as the (E) place of this scope.\",\"short\":\"[vocative]\"},\"pao\":{\"family\":\"PA\",\"long\":\"Starts a declarative sentence, that is true only because uttered (used for declarations, announcements, etc).\",\"short\":\"[declaration]\"},\"pau\":{\"family\":\"PA\",\"long\":\"Starts a directive sentence, that is requested, wished or ordered to be true.\",\"short\":\"[directive]\"},\"pai\":{\"family\":\"PAI\",\"long\":\"Ends an predicate scope.\",\"short\":\"\",\"tags\":[\"terminator\",\"elidable\"]},\"pe\":{\"family\":\"PE\",\"long\":\"Inline scope starter.\",\"short\":\"[\"},\"pei\":{\"family\":\"PEI\",\"long\":\"Inline scope elidible terminator.\",\"short\":\"]\",\"tags\":[\"terminator\",\"elidable\"]},\"pi\":{\"family\":\"PI\",\"long\":\"Ends the sequence of arguments.\",\"short\":\"[args end]\"},\"pia\":{\"family\":\"PI\",\"long\":\"Ends the sequence of arguments, and mark the scope as <EA> default predicate.\",\"short\":\"[args end EA]\"},\"po\":{\"family\":\"PO\",\"long\":\"Start a predicate definition.\",\"short\":\"[definition]\"},\"poa\":{\"family\":\"PO\",\"long\":\"Start a question definition, the arguments being the unknown informations.\",\"short\":\"[question]\"},\"poi\":{\"family\":\"POI\",\"long\":\"Ends a predicate definition.\",\"short\":\"\",\"tags\":[\"terminator\",\"elidable\"]},\"pu\":{\"family\":\"PU\",\"long\":\"Marks a new paragraph/section/change of subject.\",\"short\":\"[paragraph]\"},\"da\":{\"family\":\"DA\",\"long\":\"Emphasis indicator : the attached word is especially emphasized.\",\"short\":\"[emphasis]\"},\"daha\":{\"family\":\"DA\",\"long\":\"Nonce-word indicator : the attached word (usually a compound) may be non-standard.\",\"short\":\"[non-standard]\"},\"dahe\":{\"family\":\"DA\",\"long\":\"Attached word is a metadata tag / hashtag.\",\"short\":\"[metadata]\"},\"dae\":{\"family\":\"DA\",\"long\":\"However/but/in contrast.\",\"short\":\"[however]\"},\"dai\":{\"family\":\"DA\",\"long\":\"Similarly.\",\"short\":\"[similarly]\"},\"dao\":{\"family\":\"DA\",\"long\":\"Additionally.\",\"short\":\"[additionally]\"},\"dau\":{\"family\":\"DA\",\"long\":\"Uniquely/only/solely.\",\"short\":\"[uniquely]\"},\"de\":{\"family\":\"DE\",\"long\":\"Attach a single predicate that acts as an interjection.\",\"short\":\"\"},\"di\":{\"family\":\"DI\",\"long\":\"Attaches a subscript number/string.\",\"short\":\"[subscript]\"},\"du\":{\"family\":\"DU\",\"long\":\"Override particule meaning with provided predicate.\",\"short\":\"\"},\"do\":{\"family\":\"DO\",\"long\":\"Starts parenthetical note.\",\"short\":\"(\"},\"doi\":{\"family\":\"DOI\",\"long\":\"Ends parenthetical note.\",\"short\":\")\",\"tags\":[\"terminator\"]},\"bu\":{\"family\":\"BU\",\"long\":\"Sequence separator.\",\"short\":\"[sequence]\"},\"buhu\":{\"family\":\"BU\",\"long\":\"Erase the current sequence item.\",\"short\":\"[erased]\"},\"be\":{\"family\":\"BE\",\"long\":\"Ends string/number/borrowing.\",\"short\":\"\",\"tags\":[\"terminator\",\"elidable\",\"number\"]},\"bei\":{\"family\":\"BE\",\"long\":\"Transform a cardinal number into an ordinal : (Ec) is the [number]th member of sequence [As].\",\"short\":\"-th\",\"tags\":[\"terminator\",\"number\",\"list\"]},\"bi\":{\"family\":\"BI\",\"long\":\"Wide scope negation ranging over existential variables and predicates.\",\"short\":\"not\",\"tags\":[\"negation\"]},\"bo\":{\"family\":\"BO\",\"long\":\"Create a new variable and discard previous value if any.\",\"short\":\"new var\"},\"kor\":{\"family\":\"R\",\"long\":\"(Ec) are all the members of sequence [As].\",\"short\":\"group\",\"tags\":[\"sequence\"]},\"cna\":{\"family\":\"R\",\"long\":\"This proposition is true if all individuals in sequence (Es) satisfies property [A1].\",\"short\":\"AND-I\",\"tags\":[\"sequence\",\"connective\"]},\"cne\":{\"family\":\"R\",\"long\":\"This proposition is true if at least one individual in sequence (Es) satisfies property [A1].\",\"short\":\"OR-I\",\"tags\":[\"sequence\",\"connective\"]},\"cni\":{\"family\":\"R\",\"long\":\"This proposition is true if exactly (On) (default: 1) individuals in sequence (Es) satisfies property [A1].\",\"short\":\"XOR-I\",\"tags\":[\"sequence\",\"connective\"]},\"cena\":{\"family\":\"R\",\"long\":\"This proposition is true if all propositions in sequence (Es0) are true.\",\"short\":\"AND-P0\",\"tags\":[\"sequence\",\"connective\"]},\"cene\":{\"family\":\"R\",\"long\":\"This proposition is true if at least one proposition in sequence (Es0) is true.\",\"short\":\"OR-P0\",\"tags\":[\"sequence\",\"connective\"]},\"ceni\":{\"family\":\"R\",\"long\":\"This proposition is true if exactly (An) (default: 1) proposition(s) in sequence (Es0) is true.\",\"short\":\"XOR-P0\",\"tags\":[\"sequence\",\"connective\"]},\"cana\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ec) satisfies all properties in sequence [As1].\",\"short\":\"AND-P1\",\"tags\":[\"sequence\",\"connective\"]},\"cane\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ec) satisfies at least one property in sequence [As1].\",\"short\":\"OR-P1\",\"tags\":[\"sequence\",\"connective\"]},\"cani\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ec) satisfies exactly (On) (default: 1) proposition(s) in sequence [As1].\",\"short\":\"XOR-P1\",\"tags\":[\"sequence\",\"connective\"]},\"cona\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ec) and (Ac) satisfies all relations in sequence (Os2).\",\"short\":\"AND-P2\",\"tags\":[\"sequence\",\"connective\"]},\"cone\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ec) and (Ac) satisfies at least one relation in sequence (Os2).\",\"short\":\"OR-P2\",\"tags\":[\"sequence\",\"connective\"]},\"coni\":{\"family\":\"R\",\"long\":\"This proposition is true if (Ec) and (Ac) satisfies exactly (Un) (default: 1) relation(s) in sequence (Os2).\",\"short\":\"XOR-P2\",\"tags\":[\"sequence\",\"connective\"]},\"cir\":{\"family\":\"R\",\"long\":\"(En) is greater than [An].\",\"short\":\">\",\"tags\":[\"maths\",\"ordering\"]},\"cal\":{\"family\":\"R\",\"long\":\"(En) is less than [An].\",\"short\":\"<\",\"tags\":[\"maths\",\"ordering\"]},\"cpu\":{\"family\":\"R\",\"long\":\"(En) is equal to [An].\",\"short\":\"=\",\"tags\":[\"maths\",\"ordering\"]},\"fuir\":{\"family\":\"R\",\"long\":\"(Ed) knows fact [A0] from source (Od).\",\"short\":\"knows\"},\"zvu\":{\"family\":\"R\",\"long\":\"(Ec) satisfy relation [A2] with its future self. \\\\nAllow to describe the evolution of something.\\\\n\\\\n[A2] is used with (future, current) in this order.\\\\n\",\"short\":\"evolution\"},\"zde\":{\"family\":\"R\",\"long\":\"(Ed) [time interval] ends before the start of [Ad] (default: now) [time interval]\\\\nwith distance (On) (unitless={zgi}).\\\\n\",\"short\":\"before\",\"tags\":[\"time\"]},\"zda\":{\"family\":\"R\",\"long\":\"(Ed) [time interval] overlaps/is concurrent with [Ad] (default: now) [time interval].\",\"short\":\"concurrent\",\"tags\":[\"time\"]},\"zdo\":{\"family\":\"R\",\"long\":\"(Ed) [time interval] begins after the end of [Ad] (default: now) [time interval]\\\\nwith distance (On) (unitless={zgi}).\\\\n\",\"short\":\"after\",\"tags\":[\"time\"]},\"zdei\":{\"family\":\"R\",\"long\":\"(Ed) [time interval] starts [Ad] [time interval].  \\\\n(Ed) and [Ad] share the same starting point and (Ed) is within [Ad].\\\\n\",\"short\":\"starts\",\"tags\":[\"time\"]},\"zdai\":{\"family\":\"R\",\"long\":\"(Ed) [time interval] is within [Ad] (default: now).\",\"short\":\"within\",\"tags\":[\"time\"]},\"zdoi\":{\"family\":\"R\",\"long\":\"(Ed) [time interval] finishes [Ad] [time interval].  \\\\n(Ed) and [Ad] share the same end point and (Ed) is within [Ad].\\\\n\",\"short\":\"finishes\",\"tags\":[\"time\"]},\"skir\":{\"family\":\"R\",\"long\":\"(Ed) (default: speaker) is at the same place as [Ad] (default: speaker).\",\"short\":\"same place\",\"tags\":[\"space\"]},\"bri\":{\"family\":\"R\",\"long\":\"(Ed) (default: speaker) is above/upward/up from [Ad] (default: speaker).\",\"short\":\"up\",\"tags\":[\"space\",\"direction\"]},\"brin\":{\"family\":\"R\",\"long\":\"(Ed) (default: speaker) is below/downwars/down from [Ad] (default: speaker).\",\"short\":\"down\",\"tags\":[\"space\",\"direction\"]},\"bre\":{\"family\":\"R\",\"long\":\"(Ed) (default: speaker) is forward/to the front of [Ad] (default: speaker).\",\"short\":\"front\",\"tags\":[\"space\",\"direction\"]},\"bren\":{\"family\":\"R\",\"long\":\"(Ed) (default: speaker) is northward/to the north of [Ad] (default: speaker).\",\"short\":\"north\",\"tags\":[\"space\",\"direction\"]},\"bra\":{\"family\":\"R\",\"long\":\"(Ed) (default: speaker) is backward/to the back of [Ad] (default: speaker).\",\"short\":\"back\",\"tags\":[\"space\",\"direction\"]},\"bran\":{\"family\":\"R\",\"long\":\"(Ed) (default: speaker) is southward/to the south of [Ad] (default: speaker).\",\"short\":\"south\",\"tags\":[\"space\",\"direction\"]},\"bro\":{\"family\":\"R\",\"long\":\"(Ed) (default: speaker) is rightward/to the right of [Ad] (default: speaker).\",\"short\":\"right\",\"tags\":[\"space\",\"direction\"]},\"bron\":{\"family\":\"R\",\"long\":\"(Ed) (default: speaker) is eastward/to the east of [Ad] (default: speaker).\",\"short\":\"east\",\"tags\":[\"space\",\"direction\"]},\"bru\":{\"family\":\"R\",\"long\":\"(Ed) (default: speaker) is leftward/to the left of [Ad] (default: speaker).\",\"short\":\"left\",\"tags\":[\"space\",\"direction\"]},\"brun\":{\"family\":\"R\",\"long\":\"(Ed) (default: speaker) is westward/to the west of [Ad] (default: speaker).\",\"short\":\"west\",\"tags\":[\"space\",\"direction\"]},\"vuno\":{\"family\":\"R\",\"long\":\"(Ed) is at a distance in space of (On) (default: 1, unitless=meter) from [Ad] (default: speaker).\",\"short\":\"distance\",\"tags\":[\"space\",\"measument\"]},\"zini\":{\"family\":\"R\",\"long\":\"(Ed) [time interval] have duration (An) (default: 1, unitless={zgi}).\",\"short\":\"duration\",\"tags\":[\"time\",\"measument\"]},\"zulu\":{\"family\":\"R\",\"long\":\"(Ed) has an age/elapsed time since birth/creation of [An] (default: 1, unitless={zgi}).\",\"short\":\"age\",\"tags\":[\"time\",\"measument\"]},\"zgie\":{\"family\":\"R\",\"long\":\"(Ed) has length [An] (default: 1, unitless=meter).\",\"short\":\"length\",\"tags\":[\"space\",\"measument\"]},\"fniu\":{\"family\":\"R\",\"long\":\"(Ed) has height [An] (default: 1, unitless=meter).\",\"short\":\"height\",\"tags\":[\"space\",\"measument\"]},\"cpea\":{\"family\":\"R\",\"long\":\"(Ed) has area [An] (default: 1, unitless=meter^2).\",\"short\":\"area (measure)\",\"tags\":[\"space\",\"measument\"]},\"jvao\":{\"family\":\"R\",\"long\":\"(Ed) has volume [An] (default: 1, unitless=meter^3).\",\"short\":\"volume (measure)\",\"tags\":[\"space\",\"measument\"]},\"ckia\":{\"family\":\"R\",\"long\":\"(Ed) has speed [An] (default: 1, unitless=meter/second).\",\"short\":\"speed\",\"tags\":[\"space\",\"measument\"]},\"fsi\":{\"family\":\"R\",\"long\":\"(Ed) is a starting point of [Ad].\",\"short\":\"space start\",\"tags\":[\"space\",\"interval\"]},\"fse\":{\"family\":\"R\",\"long\":\"(Ed) is between the starting and end point of [Ad].\",\"short\":\"space between\",\"tags\":[\"space\",\"interval\"]},\"fsa\":{\"family\":\"R\",\"long\":\"(Ed) is a halt/interruption of [Ad].\",\"short\":\"space halt\",\"tags\":[\"space\",\"interval\"]},\"fso\":{\"family\":\"R\",\"long\":\"(Ed) is the resumption of [Ad].\",\"short\":\"space resumption\",\"tags\":[\"space\",\"interval\"]},\"fsu\":{\"family\":\"R\",\"long\":\"(Ed) is an end point of [Ad].\",\"short\":\"space end\",\"tags\":[\"space\",\"interval\"]},\"fena\":{\"family\":\"R\",\"long\":\"(Ed) is inside/within [Ad].\",\"short\":\"inside\",\"tags\":[\"space\"]},\"jaro\":{\"family\":\"R\",\"long\":\"(Ed) is outside [Ad].\",\"short\":\"outside\",\"tags\":[\"space\"]},\"suru\":{\"family\":\"R\",\"long\":\"(Ed) is adjacent to/along [Ad].\",\"short\":\"adjacent\",\"tags\":[\"space\"]},\"manu\":{\"family\":\"R\",\"long\":\"(Ed) is tangential/passing by [Ad].\",\"short\":\"passing by\",\"tags\":[\"space\"]},\"varu\":{\"family\":\"R\",\"long\":\"(Ed) is surrounding/around [Ad].\",\"short\":\"surrounding\",\"tags\":[\"space\"]},\"mere\":{\"family\":\"R\",\"long\":\"(Ed) is transfixing/passing through [Ad].\",\"short\":\"passing through\",\"tags\":[\"space\"]},\"tinu\":{\"family\":\"R\",\"long\":\"(Ed) is towards [Ad].\",\"short\":\"towards\",\"tags\":[\"space\"]},\"keru\":{\"family\":\"R\",\"long\":\"(Ed) is away from [Ad].\",\"short\":\"away from\",\"tags\":[\"space\"]},\"don\":{\"family\":\"R\",\"long\":\"(Ed) likes [Ad].\",\"short\":\"likes\",\"tags\":[\"emotion\"]},\"jven\":{\"family\":\"R\",\"long\":\"(Ed) is a friend of [Ad].\",\"short\":\"friend\",\"tags\":[\"emotion\"]},\"kli\":{\"family\":\"R\",\"long\":\"(Ed) thanks/is thankful to [Ad] about (O0) being true.\",\"short\":\"thanks\",\"tags\":[\"emotion\"]},\"kre\":{\"family\":\"R\",\"long\":\"(Ed) helps [Ad] to satisfy property (O1).\\\\n[Ad] is the one satisfying (O1), and (Ed) doesn\\'t need to satisfy (O1).\\\\n\",\"short\":\"helps\"},\"vaule\":{\"family\":\"R\",\"long\":\"(Ed) is milk.\",\"short\":\"milk\"},\"mian\":{\"family\":\"R\",\"long\":\"(Ed) is a cat.\",\"short\":\"cat\",\"tags\":[\"animal\"]},\"gla\":{\"family\":\"R\",\"long\":\"(Ed) [tool] is used to make [A0] [purpose] true.\",\"short\":\"tool\"},\"kali\":{\"family\":\"R\",\"long\":\"(Ed) drinks [Ad].\",\"short\":\"drinks\"},\"buri\":{\"family\":\"R\",\"long\":\"(Ed) eats [Ad].\",\"short\":\"eats\"},\"zve\":{\"family\":\"R\",\"long\":\"(Ed) is female.\",\"short\":\"female\"},\"kla\":{\"family\":\"R\",\"long\":\"(Ed) is male.\",\"short\":\"male\"},\"tsen\":{\"family\":\"R\",\"long\":\"(Ec) invents/creates/authors [Ad].\",\"short\":\"creates\"},\"zuna\":{\"family\":\"R\",\"long\":\"(Ed) is inspired by [Ad]. [Ad] is a source of inspiration for (Ed).\",\"short\":\"inspired\"},\"zvar\":{\"family\":\"R\",\"long\":\"(Ed) has goal/purpose/aims to satisfy [A1].\",\"short\":\"purpose\"},\"skao\":{\"family\":\"R\",\"long\":\"(Ed) is a computer.\",\"short\":\"computer\"},\"sni\":{\"family\":\"R\",\"long\":\"(Ed) welcomes/say hello to/greets [Ad] to place (Od).\",\"short\":\"greets\"},\"sna\":{\"family\":\"R\",\"long\":\"(Ed) says goodbye to [Ad] from place (Od).\",\"short\":\"goodbye\"},\"spi\":{\"family\":\"R\",\"long\":\"(Ed) says [Ad] to (Od).\",\"short\":\"says\"},\"spur\":{\"family\":\"R\",\"long\":\"(Ed) is a nest/house/home for [Ad].\",\"short\":\"home\"},\"zaor\":{\"family\":\"R\",\"long\":\"(Ed) agrees with [Ad] that (O0) is true.\",\"short\":\"agrees\"},\"van\":{\"family\":\"R\",\"long\":\"(Ed) goes to [Ad] from (Od).\",\"short\":\"goes\"},\"vanu\":{\"family\":\"R\",\"long\":\"(Ed) is a path to [Ad] from (Od).\",\"short\":\"path\"},\"gza\":{\"family\":\"R\",\"long\":\"(Ec) is an agentive cause of event [A0].\",\"short\":\"agentive cause\"},\"kini\":{\"family\":\"R\",\"long\":\"(Ed) learns/studies fact [A0].\",\"short\":\"learns\"},\"seru\":{\"family\":\"R\",\"long\":\"(Ed) is about subject [Ad].\",\"short\":\"about\"},\"snai\":{\"family\":\"R\",\"long\":\"(Ec) labers/works by satisfying property [A1].\",\"short\":\"works\"},\"bire\":{\"family\":\"R\",\"long\":\"(En) is 1 year times [An] (default: 1).\",\"short\":\"year\",\"tags\":[\"time\",\"unit\"]},\"gare\":{\"family\":\"R\",\"long\":\"(En) is 1 month times [An] (default: 1).\\\\nVague as months have a variable amount of days.\\\\n\",\"short\":\"month\",\"tags\":[\"time\",\"unit\"]},\"kora\":{\"family\":\"R\",\"long\":\"(En) is 1 week times [An] (default: 1).\",\"short\":\"week\",\"tags\":[\"time\",\"unit\"]},\"dena\":{\"family\":\"R\",\"long\":\"(En) is 1 day times [An] (default: 1).\",\"short\":\"day\",\"tags\":[\"time\",\"unit\"]},\"sura\":{\"family\":\"R\",\"long\":\"(En) is 1 hour times [An] (default: 1).\",\"short\":\"hour\",\"tags\":[\"time\",\"unit\"]},\"jero\":{\"family\":\"R\",\"long\":\"(En) is 1 minute times [An] (default: 1).\",\"short\":\"minute\",\"tags\":[\"time\",\"unit\"]},\"vola\":{\"family\":\"R\",\"long\":\"(En) is 1 second times [An] (default: 1).\",\"short\":\"second\",\"tags\":[\"time\",\"unit\"]},\"mual\":{\"family\":\"R\",\"long\":\"(En) is 1 meter times [An] (default: 1).\",\"short\":\"meter\",\"tags\":[\"space\",\"unit\"]},\"gulo\":{\"family\":\"R\",\"long\":\"(En) is 1 kilogram times [An] (default: 1).\",\"short\":\"kilogram\",\"tags\":[\"unit\"]},\"pere\":{\"family\":\"R\",\"long\":\"(En) is 1 ampere times [An] (default: 1).\",\"short\":\"ampere\",\"tags\":[\"unit\"]},\"keli\":{\"family\":\"R\",\"long\":\"(En) is 1 kelvin times [An] (default: 1).\",\"short\":\"kelvin\",\"tags\":[\"unit\"]},\"saur\":{\"family\":\"R\",\"long\":\"(En) is 1 candela times [An] (default: 1).\",\"short\":\"candela\",\"tags\":[\"unit\"]},\"sti\":{\"family\":\"R\",\"long\":\"(En) is the inverse (1/x) of [An] (default: 1).\",\"short\":\"inverse\",\"tags\":[\"math\"]},\"ber\":{\"family\":\"R\",\"long\":\"(Ed) reflects this language (eberban).\",\"short\":\"eberbanic\"},\"pre\":{\"family\":\"R\",\"long\":\"(Ed) is a person.\",\"short\":\"person\"},\"pra\":{\"family\":\"R\",\"long\":\"(Ed) loves [Ad].\",\"short\":\"loves\",\"tags\":[\"emotion\"]},\"vier\":{\"family\":\"R\",\"long\":\"(Ed) visits [Ad].\",\"short\":\"visits\"},\"ten\":{\"family\":\"R\",\"long\":\"(Ec) is a small (subjective) amount of things satisfying [A1].\",\"short\":\"small amount of\",\"tags\":[\"group\"]},\"tan\":{\"family\":\"R\",\"long\":\"(Ec) is a medium (subjective) amount of things satisfying [A1].\",\"short\":\"medium amount of \",\"tags\":[\"group\"]},\"ton\":{\"family\":\"R\",\"long\":\"(Ec) is a large (subjective) amount of things satisfying [A1].\",\"short\":\"large amount of\",\"tags\":[\"group\"]},\"tun\":{\"family\":\"R\",\"long\":\"(Ec) are everything/the only things that satisfies [A1] among (Oc) (default: everything).\",\"short\":\"every\",\"tags\":[\"group\"]},\"tir\":{\"family\":\"R\",\"long\":\"(En) is a negligible number times [An] (default: 1).\",\"short\":\"negligible\",\"tags\":[\"number\"]},\"ter\":{\"family\":\"R\",\"long\":\"(En) is a small number (subjective/contextual) times [An] (default: 1).\",\"short\":\"small\",\"tags\":[\"number\"]},\"tar\":{\"family\":\"R\",\"long\":\"(En) is a medium number (subjective/contextual) times [An] (default: 1).\",\"short\":\"medium\",\"tags\":[\"number\"]},\"tor\":{\"family\":\"R\",\"long\":\"(En) is a large number (subjective/contextual) times [An] (default: 1).\",\"short\":\"large\",\"tags\":[\"number\"]},\"tur\":{\"family\":\"R\",\"long\":\"(En) is an infinite number times [An] (default: 1).\",\"short\":\"infinite\",\"tags\":[\"number\"]},\"peol\":{\"family\":\"R\",\"long\":\"(Ed) is a town/city.\",\"short\":\"city\"},\"zdir\":{\"family\":\"R\",\"long\":\"(Ed) is amusing/entertaining to (Ad) (default: speaker) in property (O1).\",\"short\":\"amusing\"},\"more\":{\"family\":\"R\",\"long\":\"(Ed) is simple in property (A1).\",\"short\":\"simple\"},\"tore\":{\"family\":\"R\",\"long\":\"(Ed) is complex/complicated in property (A1).\",\"short\":\"complicated\"},\"zane\":{\"family\":\"R\",\"long\":\"(Ed) is a system with components [Ad] forming structure (Od).\",\"short\":\"system\"},\"dan\":{\"family\":\"R\",\"long\":\"(Ed) is among [Ac].\",\"short\":\"among\"},\"dar\":{\"family\":\"R\",\"long\":\"Everything among (Ed) also satisfies [A1].\\\\nFor each x among (Ed), [A1](x) is true.\\\\n\",\"short\":\"for each\"},\"speu\":{\"family\":\"R\",\"long\":\"(Es_) is ordered following ordering rule [A2].\",\"short\":\"ordering rule\"},\"fir\":{\"family\":\"R\",\"long\":\"(Ed) is a color of [Ad].\",\"short\":\"color\",\"tags\":[\"color\"]},\"cion\":{\"family\":\"R\",\"long\":\"(Ed) is [An] HSV-colored.\\\\n\\\\n[An] is a 3-vector with these components :\\\\n\\\\n{tehe} : Hue of the color between 0 and 1.\\\\n         0 is red primary.\\\\n         1/3 is green primary.\\\\n         2/3 is blue primary.\\\\n         Default: 0\\\\n\\\\n{teha} : Color saturation between 0 and 1.\\\\n         0 saturation is a shade of gray.\\\\n         Default: 1\\\\n\\\\n{teho} : Color value between 0 and 1.\\\\n         0 value is black.\\\\n         Default: 1\\\\n\",\"short\":\"HSV-color\",\"tags\":[\"color\"]},\"zen\":{\"family\":\"R\",\"long\":\"(Ed) is white/light [color adjective].\",\"short\":\"white\",\"tags\":[\"color\"]},\"gon\":{\"family\":\"R\",\"long\":\"(Ed) is black/dark [color adjective].\",\"short\":\"black\",\"tags\":[\"color\"]},\"bor\":{\"family\":\"R\",\"long\":\"(Ed) is red [color adjective].\",\"short\":\"red\",\"tags\":[\"color\"]},\"der\":{\"family\":\"R\",\"long\":\"(Ed) is green [color adjective].\",\"short\":\"green\",\"tags\":[\"color\"]},\"mir\":{\"family\":\"R\",\"long\":\"(Ed) is blue [color adjective].\",\"short\":\"blue\",\"tags\":[\"color\"]},\"zne\":{\"family\":\"R\",\"long\":\"(Ed) is cyan [color adjective].\",\"short\":\"cyan\",\"tags\":[\"color\"]},\"dzu\":{\"family\":\"R\",\"long\":\"(Ed) is magenta [color adjective].\",\"short\":\"magenta\",\"tags\":[\"color\"]},\"jgu\":{\"family\":\"R\",\"long\":\"(Ed) is yellow [color adjective].\",\"short\":\"yellow\",\"tags\":[\"color\"]},\"sare\":{\"family\":\"R\",\"long\":\"(Ec) is a group where every pair of members mutualy satisfy relation [A2].\",\"short\":\"mutual\"},\"gli\":{\"family\":\"R\",\"long\":\"(Ed) is happy about [A0] being true.\",\"short\":\"happy\"},\"siro\":{\"family\":\"R\",\"long\":\"(Ed) (source) has translation [Ad] (result).\",\"short\":\"translation\"},\"cuina\":{\"family\":\"R\",\"long\":\"(dA) is a tree.\",\"short\":\"tree\"},\"jnaor\":{\"family\":\"R\",\"long\":\"(Ed) is wild/untamed.\",\"short\":\"wild\"},\"djin\":{\"family\":\"R\",\"long\":\"(Ed) desires/wants/wishes [A0].\",\"short\":\"want\"},\"fuere\":{\"family\":\"R\",\"long\":\"(Ed) flies [in air/space].\",\"short\":\"fly\"},\"foina\":{\"family\":\"R\",\"long\":\"(Ed) is an airplane.\",\"short\":\"airplane\"},\"jle\":{\"family\":\"R\",\"long\":\"(Ed) is motivated to make [A0] true by (Od).\",\"short\":\"motivated\"},\"zuan\":{\"family\":\"R\",\"long\":\"(Ed) walks.\",\"short\":\"walks\"},\"vune\":{\"family\":\"R\",\"long\":\"(Ed) is enjoyable/great/nice for [Ad].\",\"short\":\"nice\"},\"jvin\":{\"family\":\"R\",\"long\":\"(Ed) dances.\",\"short\":\"dances\"},\"blan\":{\"family\":\"R\",\"long\":\"(Ed) is beautiful.\",\"short\":\"beautiful\"},\"kca\":{\"family\":\"R\",\"long\":\"(E0) is possible/can be true.\",\"short\":\"possible\"},\"pien\":{\"family\":\"R\",\"long\":\"(Ed) is bread.\",\"short\":\"bread\"},\"cnue\":{\"family\":\"R\",\"long\":\"(Ed) is a piece/portion/part of [Ac].\",\"short\":\"portion\"},\"ban\":{\"family\":\"R\",\"long\":\"(Ed) is expressed in language [Ad].\",\"short\":\"language\"},\"vin\":{\"family\":\"R\",\"long\":\"(Ed) is written/inscribed on display/storage medium [Ad].\",\"short\":\"written\"},\"soane\":{\"family\":\"R\",\"long\":\"(Ed) is stolen from [Ad].\\\\n\\\\nUse with {gza} to express who/what steals (Ed).\\\\n\",\"short\":\"stolen\"},\"sfi\":{\"family\":\"R\",\"long\":\"(Ed) is the abstract concept of [A0].\",\"short\":\"concept\"},\"sfe\":{\"family\":\"R\",\"long\":\"(Ed) [time interval] is an occurrence of [A0] being true.\\\\n[A0] is true at each instant of (Ed), and was not true immediately before and after this interval.\\\\n\",\"short\":\"occurence\"},\"sfa\":{\"family\":\"R\",\"long\":\"(Ed) is the property [A1].\",\"short\":\"property\"},\"sfo\":{\"family\":\"R\",\"long\":\"(Ed) is the relation [A2].\",\"short\":\"relation\"},\"sfu\":{\"family\":\"R\",\"long\":\"(Ed) is the fact that [A0] is true.\",\"short\":\"fact\"},\"tri\":{\"family\":\"R\",\"long\":\"(Ed) tries/attemps to do/bring about [A0]. Success is neither implied or disimplied.\",\"short\":\"attemps\"},\"tcu\":{\"family\":\"R\",\"long\":\"(Ed) requires/needs [A0] to being true. [A0] is a necessity for (Ed).\",\"short\":\"needs\"},\"minu\":{\"family\":\"R\",\"long\":\"(Ed) sleeps.\",\"short\":\"sleeps\"},\"jun\":{\"family\":\"R\",\"long\":\"(Ed) is good.\",\"short\":\"good\"},\"gur\":{\"family\":\"R\",\"long\":\"(Ed) is bad.\",\"short\":\"bad\"},\"kin\":{\"family\":\"R\",\"long\":\"(Ed) is a kind of [Ad].\",\"short\":\"kind\"},\"kunu\":{\"family\":\"R\",\"long\":\"(Ed) feels sentiment/emotion/sensation [Ad].\",\"short\":\"feels\"},\"viru\":{\"family\":\"R\",\"long\":\"(Ed) sees [Ad].\",\"short\":\"sees\"},\"pure\":{\"family\":\"R\",\"long\":\"(Ed) hears/listen to [Ad].\",\"short\":\"hears\"},\"cen\":{\"family\":\"R\",\"long\":\"(Ed) is a word.\",\"short\":\"word\"},\"vina\":{\"family\":\"R\",\"long\":\"(Ed) is alive.\",\"short\":\"alive\"},\"mori\":{\"family\":\"R\",\"long\":\"(Ed) is dead.\",\"short\":\"dead\"},\"suer\":{\"family\":\"R\",\"long\":\"(Ed) is similar to/like [Ad].\",\"short\":\"similar\"},\"paor\":{\"family\":\"R\",\"long\":\"(Ed) is the truth.\",\"short\":\"truth\"},\"cfeo\":{\"family\":\"R\",\"long\":\"(Ed) is a solid [state of matter].\",\"short\":\"solid\",\"tags\":[\"matter\"]},\"zrao\":{\"family\":\"R\",\"long\":\"(Ed) is a liquid [state of matter].\",\"short\":\"liquid\",\"tags\":[\"matter\"]},\"djio\":{\"family\":\"R\",\"long\":\"(Ed) is a gaz [state of matter].\",\"short\":\"gaz\",\"tags\":[\"matter\"]},\"jeno\":{\"family\":\"R\",\"long\":\"(Ed) is water.\",\"short\":\"water\",\"tags\":[\"matter\"]},\"gouru\":{\"family\":\"R\",\"long\":\"(Ed) is a dog.\",\"short\":\"dog\",\"tags\":[\"animal\"]},\"kanae\":{\"family\":\"R\",\"long\":\"(Ed) is a wolf.\",\"short\":\"wolf\",\"tags\":[\"animal\"]},\"kroan\":{\"family\":\"R\",\"long\":\"(Ed) is a frog.\",\"short\":\"frog\",\"tags\":[\"animal\"]},\"tori\":{\"family\":\"R\",\"long\":\"(Ed) is a bird.\",\"short\":\"bird\",\"tags\":[\"animal\"]},\"cein\":{\"family\":\"R\",\"long\":\"(Ed) is a room.\",\"short\":\"room\"},\"caun\":{\"family\":\"R\",\"long\":\"(Ed) is an animal.\",\"short\":\"animal\",\"tags\":[\"animal\"]},\"flur\":{\"family\":\"R\",\"long\":\"(Ed) is a plant.\",\"short\":\"plant\"},\"jveno\":{\"family\":\"R\",\"long\":\"(Ed) is kind/behaves friendly towards [Ad].\",\"short\":\"kind\"},\"slari\":{\"family\":\"R\",\"long\":\"(Ed) is a rule/law prescribing/mandating/requiring [A0].\",\"short\":\"rule\"},\"zire\":{\"family\":\"R\",\"long\":\"(Ed) respects [Ad].\",\"short\":\"respects\"},\"zvoe\":{\"family\":\"R\",\"long\":\"(Ed) is a content, something that is to be expressed though medium (Ad).\",\"short\":\"content\"},\"zbui\":{\"family\":\"R\",\"long\":\"(Ed) have sex/sexual intercourse/copulates/mates with [Ad].\",\"short\":\"sex\"},\"jiro\":{\"family\":\"R\",\"long\":\"(Ed) shares [Ad] with (Od).\",\"short\":\"shares\"},\"mare\":{\"family\":\"R\",\"long\":\"(Ed) is legal, allowed by authority (Ad).\",\"short\":\"allowed\"},\"sier\":{\"family\":\"R\",\"long\":\"(Ed) is the Internet.\",\"short\":\"internet\"},\"stini\":{\"family\":\"R\",\"long\":\"(Ed) is rigid/not bandable.\",\"short\":\"rigid\"},\"merue\":{\"family\":\"R\",\"long\":\"(Ed) is an organism / form of life.\",\"short\":\"organism\"},\"slaen\":{\"family\":\"R\",\"long\":\"(Ed) is tied/pinned to [Ad].\",\"short\":\"tied\"},\"gan\":{\"family\":\"R\",\"long\":\"(Ed) is something that contains this word.\",\"short\":\"this\"},\"skien\":{\"family\":\"R\",\"long\":\"(Ed) is a computer program.\",\"short\":\"program\"},\"sen\":{\"family\":\"R\",\"long\":\"If (E0) is true then [A0] is true, otherwise (O0) is true.\",\"short\":\"if then\"},\"zari\":{\"family\":\"R\",\"long\":\"(Ed) is a recipe, algorithm, procedure to achieve result [Ad].\",\"short\":\"recipe\"},\"zein\":{\"family\":\"R\",\"long\":\"(Ed) [supply/commodity] is provided to [Ad].\\\\n\\\\nUse with {gza} to express who/what provides (Ed).\\\\n\",\"short\":\"provided\"},\"curo\":{\"family\":\"R\",\"long\":\"(Ed) is the grammar of [Ad].\",\"short\":\"grammar\"},\"cpena\":{\"family\":\"R\",\"long\":\"(Ed) is a document with content [Ad].\",\"short\":\"document\"},\"tsir\":{\"family\":\"R\",\"long\":\"(Ed) finds/discovers [Ad].\",\"short\":\"finds\"},\"tcon\":{\"family\":\"R\",\"long\":\"(Ed) is related to/associated wit/akin to [Ad] by relationship (O2).\",\"short\":\"related\"},\"bun\":{\"family\":\"R\",\"long\":\"(Ed) is a version of [Ad].\",\"short\":\"version\"},\"bju\":{\"family\":\"R\",\"long\":\"(Ed) is a text.\",\"short\":\"text\"},\"bion\":{\"family\":\"R\",\"long\":\"(Ed) is ill/sick from disease [Ad].\",\"short\":\"sick\"},\"saul\":{\"family\":\"R\",\"long\":\"(Ed) is light [energy].\",\"short\":\"light\"},\"cmir\":{\"family\":\"R\",\"long\":\"(Ed) emits/produce [Ad].\",\"short\":\"emits\"},\"smai\":{\"family\":\"R\",\"long\":\"(Ed) receives/absorbs [Ad].\",\"short\":\"receives\"},\"flua\":{\"family\":\"R\",\"long\":\"(Ed) is a sound.\",\"short\":\"sound\"},\"fana\":{\"family\":\"R\",\"long\":\"(Ed) is a parent of [Ad].\",\"short\":\"parent\",\"tags\":[\"kinship\",\"family\"]},\"kana\":{\"family\":\"R\",\"long\":\"(Ed) is a sibling/brother/sister of [Ad].\",\"short\":\"sibling\",\"tags\":[\"kinship\",\"family\"]},\"mana\":{\"family\":\"R\",\"long\":\"(Ed) is a mother of [Ad].\\\\nEquivalent to {zve fana}.\\\\n\",\"short\":\"mother\",\"tags\":[\"kinship\",\"family\"]},\"pana\":{\"family\":\"R\",\"long\":\"(Ed) is a father of [Ad].\\\\nEquivalent to {kla fana}.\\\\n\",\"short\":\"father\",\"tags\":[\"kinship\",\"family\"]},\"dzana\":{\"family\":\"R\",\"long\":\"(Ed) is married to [Ad].\",\"short\":\"married\",\"tags\":[\"kinship\",\"family\"]},\"kineo\":{\"family\":\"R\",\"long\":\"(Ed) touches [Ad].\",\"short\":\"touches\"},\"vario\":{\"family\":\"R\",\"long\":\"(Ed) is strange/weird.\",\"short\":\"strange\"},\"zvao\":{\"family\":\"R\",\"long\":\"(E0) is an accident/unintentional.\",\"short\":\"accident\"},\"tera\":{\"family\":\"R\",\"long\":\"(Ed) is a planet.\",\"short\":\"planet\"},\"sora\":{\"family\":\"R\",\"long\":\"(Ed) is a star.\",\"short\":\"star\"},\"zila\":{\"family\":\"R\",\"long\":\"(Ed) is a major natural satellite/moon.\",\"short\":\"moon\"},\"zoni\":{\"family\":\"R\",\"long\":\"(Ed) pertains to [Ad].\",\"short\":\"pertains\"},\"kari\":{\"family\":\"R\",\"long\":\"(Ed) has axiomatic belief that [A0] is true.\\\\n[A0] is an axiom, is presupposed to be true and it\\'s truth value is never\\\\nput into doupt.\\\\n\",\"short\":\"axiom\"},\"menoe\":{\"family\":\"R\",\"long\":\"(Ed) is an apple.\",\"short\":\"apple\"},\"kcaro\":{\"family\":\"R\",\"long\":\"(Ed) is an table.\",\"short\":\"table\"},\"guro\":{\"family\":\"R\",\"long\":\"(Ed) is a country/territory.\",\"short\":\"country\"},\"drai\":{\"family\":\"R\",\"long\":\"(Ed) is a god.\",\"short\":\"god\"},\"mene\":{\"family\":\"R\",\"long\":\"(Ec) comes (On) (default: 1) places after [Ac] in sequence (Us).\",\"short\":\"comes after\"},\"dara\":{\"family\":\"R\",\"long\":\"(Ec) comes (On) (default: 1) places before [Ac] in sequence (Us)\",\"short\":\"comes before\"},\"marne\":{\"family\":\"R\",\"long\":\"(Ec) can be metaphorically compared to [Ac].\",\"short\":\"metaphor\"},\"kroni\":{\"family\":\"R\",\"long\":\"(Ed) is a leg.\",\"short\":\"leg\"},\"kani\":{\"family\":\"R\",\"long\":\"(Ed) infers from their current sensorial experience that [A0] is the case.\",\"short\":\"infers from senses\"},\"mara\":{\"family\":\"R\",\"long\":\"(Ed) remembers the past experience of perceiving that [A0] was the case.\",\"short\":\"remembers\"},\"zule\":{\"family\":\"R\",\"long\":\"(Ed) has got second-hand information or hearsay according to which [A0] is the case.\",\"short\":\"hearsay\"},\"muni\":{\"family\":\"R\",\"long\":\"(Ed) intuits that [A0] is the case.\",\"short\":\"intuits\"},\"sana\":{\"family\":\"R\",\"long\":\"(Ed) has cultural knowledge, collective wisdom according to which [A0] is the case.\",\"short\":\"cultural knowledge\"},\"valo\":{\"family\":\"R\",\"long\":\"(Ed) infers (from several sources of information) that [A0] is the case.\",\"short\":\"infers from multiple sources\"},\"bael\":{\"family\":\"R\",\"long\":\"(Ed) is standing.\",\"short\":\"standing\"},\"ctua\":{\"family\":\"R\",\"long\":\"(Ed) is sitting on [Ad].\",\"short\":\"sit\"},\"pron\":{\"family\":\"R\",\"long\":\"(Ed) is lying down on [Ad].\",\"short\":\"lying down\"},\"gavgi\":{\"family\":\"R\",\"long\":\" (Ed) is a crystal/gem/mineral with orderly atomic structure (Ad).\",\"short\":\"crystal\"},\"jala\":{\"family\":\"R\",\"long\":\" (Ed) is awake.\",\"short\":\"awake\"},\"celia\":{\"family\":\"R\",\"long\":\" (Ed) is the science/study/body of knowledge about topic [Ad].\",\"short\":\"science\"},\"filu\":{\"family\":\"R\",\"long\":\" (Ed) gives birth to/begets [Ad].\",\"short\":\"gives birth\"},\"del\":{\"family\":\"R\",\"long\":\" (Ed) is a typical/average representative of something that satisfies [A1].\",\"short\":\"typical\"},\"zmi\":{\"family\":\"R\",\"long\":\"(Ed) is the least in property [A1] in population/sample (Oc) (default: contextual).\\\\n\\\\n\\\\\"Least\\\\\" means being the lowest in the population.\\\\nThe property must have a clear ordering strategy.\\\\n\",\"short\":\"least\",\"tags\":[\"intensity\"]},\"zma\":{\"family\":\"R\",\"long\":\"(Ed) is moderate in property [A1] in population/sample (Oc) (default: contextual).\\\\n\\\\n\\\\\"Moderate\\\\\" means being close to the median in the population.\\\\nThe property must have a clear ordering strategy.\\\\n\",\"short\":\"moderate\",\"tags\":[\"intensity\"]},\"zmu\":{\"family\":\"R\",\"long\":\"(Ed) is the most in property [A1] in population/sample (Oc) (default: contextual).\\\\n\\\\n\\\\\"Most\\\\\" means being the highest in the population.\\\\nThe property must have a clear ordering strategy.\\\\n\",\"short\":\"most\",\"tags\":[\"intensity\"]},\"zmie\":{\"family\":\"R\",\"long\":\"(Ed) is very little in property [A1] in population/sample (Oc) (default: contextual).\\\\n\\\\n\\\\\"Very little\\\\\" means being below the first quartile in the population.\\\\nThe property must have a clear ordering strategy.\\\\n\",\"short\":\"very little\",\"tags\":[\"intensity\"]},\"zmea\":{\"family\":\"R\",\"long\":\"(Ed) is little in property [A1] in population/sample (Oc) (default: contextual).\\\\n\\\\n\\\\\"Little\\\\\" means being between the first quartile and the median in the population.\\\\nThe property must have a clear ordering strategy.\\\\n\",\"short\":\"little\",\"tags\":[\"intensity\"]},\"zmao\":{\"family\":\"R\",\"long\":\"(Ed) is much in property [A1] in population/sample (Oc) (default: contextual).\\\\n\\\\n\\\\\"Much\\\\\" means being between the median and the third quartile in the population.\\\\nThe property must have a clear ordering strategy.\\\\n\",\"short\":\"much\",\"tags\":[\"intensity\"]},\"zmou\":{\"family\":\"R\",\"long\":\"(Ed) is very much in property [A1] in population/sample (Oc) (default: contextual).\\\\n\\\\n\\\\\"Very much\\\\\" means being between above the third quartile in the population.\\\\nThe property must have a clear ordering strategy.\\\\n\",\"short\":\"much\",\"tags\":[\"intensity\"]},\"sahar\":{\"family\":\"R\",\"long\":\" (Ed) is a flower.\",\"short\":\"flower\"},\"kena\":{\"family\":\"R\",\"long\":\" (Ed) holds/grasps [Ad].\",\"short\":\"holds\"},\"clo\":{\"family\":\"R\",\"long\":\" (Ed) have purpose to satisfy property [A1].\",\"short\":\"purpose\"},\"jara\":{\"family\":\"R\",\"long\":\" (Ed) has satisfying property [A1] as one of their jobs/occupations (paid work).\",\"short\":\"paid work\"},\"zera\":{\"family\":\"R\",\"long\":\" (Ed) has satisfying property [A1] as a personality trait.\",\"short\":\"personality trait\"},\"bzen\":{\"family\":\"R\",\"long\":\" (E0) is the case for reason (A0).\",\"short\":\"reason\"},\"blae\":{\"family\":\"R\",\"long\":\" (Ed) is owned by [Ac].\",\"short\":\"owned\"},\"tse\":{\"family\":\"R\",\"long\":\" (En) is the amount of individual things in [Ac].\",\"short\":\"amount\"},\"zgi\":{\"family\":\"R\",\"long\":\"(En) is the duration expressed by number [An].\\\\n\\\\n[An] uses number vector notation to quickly express durations or dates.  \\\\n- {tehe} : seconds ({vola})  \\\\n- {teha} : minutes ({jero})  \\\\n- {teho} : hours ({sura})  \\\\n- {tehu} : days ({dena})  \\\\n- {tehei} : weeks ({kora})  \\\\n- {tehai} : months ({gare})  \\\\n- {tehoi} : years ({bire})  \\\\n\",\"short\":\"duration (vec)\",\"tags\":[\"time\",\"vector\"]},\"dzui\":{\"family\":\"R\",\"long\":\" (Ec) is able to satisfy property [A1].\",\"short\":\"able\"},\"dukma\":{\"family\":\"R\",\"long\":\" (Ed) is magic/sorcery/witchcraft.\",\"short\":\"magic\"},\"bena\":{\"family\":\"R\",\"long\":\" (Ed) is healthy/fit/well/in good health.\",\"short\":\"healthy\"},\"jogma\":{\"family\":\"R\",\"long\":\"(Ed) is a wound.\",\"short\":\"wound\"},\"melu\":{\"family\":\"R\",\"long\":\"(Ed) (default: water) is raining.\",\"short\":\"rain\"},\"bein\":{\"family\":\"R\",\"long\":\"(Ec) is the last member of sequence [As].\",\"short\":\"last\",\"tags\":[\"number\",\"list\"]},\"seni\":{\"family\":\"R\",\"long\":\"(E0) is obligated to be performed under authority (Ac). (E0) is a duty.\\\\n\\\\nExamples: praying (in some religions), voting (in some countries), parents\\\\ntaking care of their children is societally obligated\\\\n\",\"short\":\"obligated\"},\"sene\":{\"family\":\"R\",\"long\":\"(E0) is encouraged to be performed under authority (Ac). \\\\n(Ed) is a virtuous/upstanding behavior.\\\\n\\\\nExamples: charity, volunteer work, being polite\\\\n\",\"short\":\"encouraged\"},\"sena\":{\"family\":\"R\",\"long\":\"(E0) is neither encouraged nor discouraged (i.e. permitted) by authority (Ac).\\\\n(E0) is tolerated.  \\\\n\\\\nExamples: basically most actions are {sena}, there are so many examples\\\\n-- the act of breathing is sena\\\\n\",\"short\":\"tolerated\"},\"seno\":{\"family\":\"R\",\"long\":\"(E0) is discouraged to be performed under authority (Ac); (Ed) is reprehensible.\\\\n\\\\nExamples: lying (not under oath), crimes with are technically illegal but\\\\nnot prosecuted, laughing at a funeral, breaking certain religious laws\\\\n\",\"short\":\"discouraged\"},\"senu\":{\"family\":\"R\",\"long\":\"(E0) is forbidden to be done by authority (Ac).\\\\n\\\\nExamples: for many religions speaking badly of their deity is forbidden,\\\\ncrimes which are prosecuted, cheating on your partner in a monogamous relationship\\\\n\",\"short\":\"forbidden\"},\"molai\":{\"family\":\"R\",\"long\":\"(Ec) is made to satisfy [A1] as a reward/punishment.  \\\\n(Ec) is awarded/punished, with result that they satisfy [A1].\\\\n\",\"short\":\"reward/punishment\"},\"buiur\":{\"family\":\"R\",\"long\":\"(Ed) is meat from animal/source [Ad].\",\"short\":\"meat\"},\"e tsen ban\":{\"family\":\"C2\",\"long\":\"(Ed) is a constructed language/conlang.\",\"short\":\"conlang\"},\"e ber ban\":{\"family\":\"C2\",\"long\":\"(Ed) is the eberban language.\",\"short\":\"eberban\",\"tags\":[\"cultural\"]},\"e ujbo ban\":{\"family\":\"C2\",\"long\":\"(Ed) is the lojban language.\",\"short\":\"lojban\",\"tags\":[\"cultural\"]},\"e ufranse ban\":{\"family\":\"C2\",\"long\":\"(Ed) is the french language.\",\"short\":\"french language\",\"tags\":[\"cultural\"]},\"e ufranse guro\":{\"family\":\"C2\",\"long\":\"(Ed) is France.\",\"short\":\"France\",\"tags\":[\"cultural\"]},\"e uinglici ban\":{\"family\":\"C2\",\"long\":\"(Ed) is the english language.\",\"short\":\"english language\",\"tags\":[\"cultural\"]},\"e unihon ban\":{\"family\":\"C2\",\"long\":\"(Ed) is the japanese language.\",\"short\":\"japanese language\",\"tags\":[\"cultural\"]},\"e unihon guro\":{\"family\":\"C2\",\"long\":\"(Ed) is Japan.\",\"short\":\"Japan\",\"tags\":[\"cultural\"]},\"e udjonguo ban\":{\"family\":\"C2\",\"long\":\"(Ed) is chinese language.\",\"short\":\"chinese language\",\"tags\":[\"cultural\"]},\"e udjonguo guro\":{\"family\":\"C2\",\"long\":\"(Ed) is China.\",\"short\":\"China\",\"tags\":[\"cultural\"]},\"e udoitce ban\":{\"family\":\"C2\",\"long\":\"(Ed) is german language.\",\"short\":\"german language\",\"tags\":[\"cultural\"]},\"e udoitce guro\":{\"family\":\"C2\",\"long\":\"(Ed) is Germany.\",\"short\":\"Germany\",\"tags\":[\"cultural\"]},\"e umiser guro\":{\"family\":\"C2\",\"long\":\"(Ed) is Egypt.\",\"short\":\"Egypt\",\"tags\":[\"cultural\"]},\"e uhangu ban\":{\"family\":\"C2\",\"long\":\"(Ed) is korean language.\",\"short\":\"korean language\",\"tags\":[\"cultural\"]},\"e uhangu guro\":{\"family\":\"C2\",\"long\":\"(Ed) is South Korea.\",\"short\":\"South Korea\",\"tags\":[\"cultural\"]},\"e utcoson ban\":{\"family\":\"C2\",\"long\":\"(Ed) is korean language.\",\"short\":\"korean language\",\"tags\":[\"cultural\"]},\"e utcoson guro\":{\"family\":\"C2\",\"long\":\"(Ed) is North Korea.\",\"short\":\"North Korea\",\"tags\":[\"cultural\"]},\"e te dena\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is a Sunday.\",\"short\":\"Sunday\",\"tags\":[\"time\",\"day\"]},\"e ta dena\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is a Monday.\",\"short\":\"Monday\",\"tags\":[\"time\",\"day\"]},\"e to dena\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is a Thusday.\",\"short\":\"Thusday\",\"tags\":[\"time\",\"day\"]},\"e tu dena\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is a Wednesday.\",\"short\":\"Wednesday\",\"tags\":[\"time\",\"day\"]},\"e tei dena\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is a Thursday.\",\"short\":\"Thursday\",\"tags\":[\"time\",\"day\"]},\"e tai dena\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is a Friday.\",\"short\":\"Friday\",\"tags\":[\"time\",\"day\"]},\"e toi dena\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is a Saturday.\",\"short\":\"Saturday\",\"tags\":[\"time\",\"day\"]},\"e tui dena\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is a Sunday.\",\"short\":\"Sunday\",\"tags\":[\"time\",\"day\"]},\"e te gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is January.\",\"short\":\"January\",\"tags\":[\"time\",\"month\"]},\"e ta gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is February.\",\"short\":\"February\",\"tags\":[\"time\",\"month\"]},\"e to gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is March.\",\"short\":\"March\",\"tags\":[\"time\",\"month\"]},\"e tu gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is April.\",\"short\":\"April\",\"tags\":[\"time\",\"month\"]},\"e tai gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is May.\",\"short\":\"May\",\"tags\":[\"time\",\"month\"]},\"e tei gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is June.\",\"short\":\"June\",\"tags\":[\"time\",\"month\"]},\"e toi gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is July.\",\"short\":\"July\",\"tags\":[\"time\",\"month\"]},\"e tui gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is August.\",\"short\":\"August\",\"tags\":[\"time\",\"month\"]},\"e tie gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is September.\",\"short\":\"September\",\"tags\":[\"time\",\"month\"]},\"e tia gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is October.\",\"short\":\"October\",\"tags\":[\"time\",\"month\"]},\"e tio gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is November.\",\"short\":\"October\",\"tags\":[\"time\",\"month\"]},\"e tiu gare\":{\"family\":\"C2\",\"long\":\"(Ed) [time interval] is December.\",\"short\":\"December\",\"tags\":[\"time\",\"month\"]},\"e kre vier\":{\"family\":\"C2\",\"long\":\"(Ed) visits [Ad] with guide (Od).\",\"short\":\"guided visit\"},\"e vin zane\":{\"family\":\"C2\",\"long\":\"(Ed) is a writing system with symbols (Ad) and set of rules (Os0).\",\"short\":\"writing system\"},\"e spi tori\":{\"family\":\"C2\",\"long\":\"(Ed) is a parrot.\",\"short\":\"parrot\",\"tags\":[\"animal\"]},\"e sier vanu\":{\"family\":\"C2\",\"long\":\"(Ed) is an hyperlink to/URL of resource [Ad].\",\"short\":\"hyperlink\"},\"e merue zane\":{\"family\":\"C2\",\"long\":\"(Ec) is an organism with body parts [Ac] forming body (Oc).\",\"short\":\"body\"},\"e gze slaen\":{\"family\":\"C2\",\"long\":\"(Ed) hangs from [Ad].\",\"short\":\"hang\"},\"e skao zari\":{\"family\":\"C2\",\"long\":\"(Ed) is a source code of [Ad].\",\"short\":\"source code\"},\"e curo skien\":{\"family\":\"C2\",\"long\":\"(Ed) is a parser from grammar [Ad].\",\"short\":\"parser\"},\"e pu zoi\":{\"family\":\"C2\",\"long\":\"(Ed) is a paragraph.\",\"short\":\"paragraph\"},\"e bion cnue\":{\"family\":\"C2\",\"long\":\"(Ed) [ill/sickness] is characterized by symptom [A1].\",\"short\":\"symptom\"},\"e tor vuno\":{\"family\":\"C2\",\"long\":\"(Ed) is far (large distance) from [Ad].\",\"short\":\"far\"},\"e ter vuno\":{\"family\":\"C2\",\"long\":\"(Ed) is close (short distance) to [Ad].\",\"short\":\"close\"},\"e za zoi\":{\"family\":\"C2\",\"long\":\"(Ed) is a name of [Ac].\",\"short\":\"name\"},\"e spur tera\":{\"family\":\"C2\",\"long\":\"(Ed) is the home planet of species (Ad) (default: humans).\",\"short\":\"home planet\"},\"e spur sora\":{\"family\":\"C2\",\"long\":\"(Ed) is the home star of species (Ad) (default: humans).\",\"short\":\"home star\"},\"e dena zdo\":{\"family\":\"C2\",\"long\":\"(E0) occurs one day after (A0) (default: today).\\\\nUsing only the E place thus defaults to \\\\\"tomorrow\\\\\".\\\\n\",\"short\":\"next day\",\"tags\":[\"time\",\"measument\",\"ordering\"]},\"e dena zde\":{\"family\":\"C2\",\"long\":\"(E0) occurs one day before (A0) (default: today).\\\\nUsing only the E place thus defaults to \\\\\"yesterday\\\\\".\\\\n\",\"short\":\"previous day\",\"tags\":[\"time\",\"measument\",\"ordering\"]},\"e dena zda\":{\"family\":\"C2\",\"long\":\"(E0) occurs today.\",\"short\":\"today\",\"tags\":[\"time\"]},\"e cpu cir\":{\"family\":\"C2\",\"long\":\"(En) is greater than or equal to [An].\",\"short\":\"\",\"tags\":[\"maths\",\"ordering\"]},\"e cpu cal\":{\"family\":\"C2\",\"long\":\"(En) is less than or equal to [An].\",\"short\":\"\",\"tags\":[\"maths\",\"ordering\"]},\"e fniu cal\":{\"family\":\"C2\",\"long\":\"(Ed) is less tall than [Ad].\",\"short\":\"less tall\",\"tags\":[\"space\",\"measument\",\"ordering\"]},\"e fniu cir\":{\"family\":\"C2\",\"long\":\"(Ed) is taller than [Ad].\",\"short\":\"taller\",\"tags\":[\"space\",\"measument\",\"ordering\"]},\"e jvao cal\":{\"family\":\"C2\",\"long\":\"(Ed) is smaller/has less volume tall than [Ad].\",\"short\":\"smaller\",\"tags\":[\"space\",\"measument\",\"ordering\"]},\"e jvao cir\":{\"family\":\"C2\",\"long\":\"(Ed) is bigger/has more volume than [Ad].\",\"short\":\"bigger \",\"tags\":[\"space\",\"measument\",\"ordering\"]},\"e zulu cal\":{\"family\":\"C2\",\"long\":\"(Ed) is younger than [Ad].\",\"short\":\"younger\",\"tags\":[\"time\",\"measument\",\"ordering\"]},\"e zulu cir\":{\"family\":\"C2\",\"long\":\"(Ed) is older than [Ad].\",\"short\":\"older\",\"tags\":[\"time\",\"measument\",\"ordering\"]},\"e jven kena\":{\"family\":\"C2\",\"long\":\"(Ed) hugs [Ad].\",\"short\":\"hugs\"},\"e ter zde\":{\"family\":\"C2\",\"long\":\"(Ed) (default: now) [time interval] occurs a short time before/in the past of [Ad] (default: now) [time interval].\",\"short\":\"short time before\",\"tags\":[\"time\",\"measument\",\"ordering\"]},\"e tar zde\":{\"family\":\"C2\",\"long\":\"(Ed) (default: now) [time interval] occurs a medium time before/in the past of [Ad] (default: now) [time interval].\",\"short\":\"medium time before\",\"tags\":[\"time\",\"measument\",\"ordering\"]},\"e tor zde\":{\"family\":\"C2\",\"long\":\"(Ed) (default: now) [time interval] occurs a long time before/in the past of [Ad] (default: now) [time interval].\",\"short\":\"long time before\",\"tags\":[\"time\",\"measument\",\"ordering\"]},\"e ter zdo\":{\"family\":\"C2\",\"long\":\"(Ed) (default: now) [time interval] occurs a short time after/in the future of [Ad] (default: now) [time interval].\",\"short\":\"short time after\",\"tags\":[\"time\",\"measument\",\"ordering\"]},\"e tar zdo\":{\"family\":\"C2\",\"long\":\"(Ed) (default: now) [time interval] occurs a medium time after/in the future of [Ad] (default: now) [time interval].\",\"short\":\"medium time after\",\"tags\":[\"time\",\"measument\",\"ordering\"]},\"e tor zdo\":{\"family\":\"C2\",\"long\":\"(Ed) (default: now) [time interval] occurs a long time after/in the future of [Ad] (default: now) [time interval].\",\"short\":\"long time after\",\"tags\":[\"time\",\"measument\",\"ordering\"]},\"e cmo bena\":{\"family\":\"C2\",\"long\":\"(Ed) heals/recovers/returns to health.\",\"short\":\"heals\"},\"a cen po bu\":{\"family\":\"C3\",\"long\":\"(Ed) is a dictionary.\",\"short\":\"dictionary\"}}');\n\n//# sourceURL=webpack://bundle/../dictionary/en.yaml?");

/***/ }),

/***/ "./src/dictionary.js":
/*!***************************!*\
  !*** ./src/dictionary.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports.dictionary_en = __webpack_require__(/*! ../../dictionary/en.yaml */ \"../dictionary/en.yaml\");\n\nconst alphabet = 'hnlrmpbfvtdszcjkgieaou';\n\nlet symbol_indices = {};\n\nfor (i = 0; i < alphabet.length; i++) {\n    symbol_indices[alphabet[i]] = i;\n}\n\nconsole.log({symbol_indices});\n\nfunction compare_words(x, y) {\n    if (x == y) {\n        return 0;\n    }\n\n    for(i = 0; i < x.length; i++) {\n        if (i >= y.length) {\n            return 1; // y is shorter and \n        }\n\n        let sx = symbol_indices[x[i]];\n        let sy = symbol_indices[y[i]];\n\n        // earlier in the alphabet => first to appear\n        if (sx < sy) {\n            return -1;\n        } else if (sx > sy) {\n            return 1;\n        }\n    }\n}\n\nmodule.exports.compare_words = compare_words;\n\n//# sourceURL=webpack://bundle/./src/dictionary.js?");

/***/ }),

/***/ "./src/process_parse_tree.js":
/*!***********************************!*\
  !*** ./src/process_parse_tree.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * CAMXES.JS POSTPROCESSOR\n * \n * Entry point: camxes_postprocessing(input, mode)\n * \n * Arguments:\n *     input: [array]  Camxes' parse tree output.\n *          OR [string] JSON stringified parse tree.\n *     mode:  [string] Parse tree processing option list (each option is\n *                      symbolized by a letter). See below for details.\n *          OR [number] (Deprecated) Older options representation encoded as\n *                      bit flags on a number.\n * \n * Return value:\n *       [string] postprocessed version of camxes' output\n * \n * Details for the `mode arguent's values:\n * \n * The mode argument can be any letter string, each letter stands for a specific\n * option. Here is the list of possible letters and their associated meaning:\n *    'J' -> JSON output format\n *    'I' -> Indented JSON output format\n *    'M' -> Keep morphology\n *    'S' -> Show spaces\n *    'T' -> Show terminators\n *    'C' -> Show word classes (selmaho)\n *    'R' -> Raw output, do not trim the parse tree. If this option isn't set,\n *           all the nodes (with the exception of those saved if the 'N' option\n *           is set) are pruned from the tree.\n *    'N' -> Show main node labels\n *    'G' -> Show glosses instead of Lojban\n */\n\n/*\n * Function list:\n *   -- camxes_postprocessing(text, mode)\n *   -- newer_postprocessor(parse_tree, with_morphology, with_spaces,\n *                          with_terminators, with_trimming, with_selmaho,\n *                          with_nodes_labels)\n *   -- process_parse_tree(parse_tree, value_substitution_map,\n *                         name_substitution_map, node_action_for,\n *                         must_prefix_leaf_labels)\n *   -- among(v, s)\n *   -- is_family(v)\n *   -- prettify_brackets(str)\n *   -- str_print_uint(val, charset)\n *   -- str_replace(str, pos, len, sub)\n *   -- is_string(v)\n *   -- is_array(v)\n *   -- is_number(v)\n */\n\n// var glosser = require('../gismudata.js');\n\nif (typeof alert !== 'function') alert = console.log; // For Node.js\n\nconst { is_array, is_family, is_string, is_number } = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\n/*\n * Main function.\n */\nfunction camxes_postprocessing(input, mode) {\n\t/* Checking the input */\n\tif (is_string(input)) input = JSON.parse(input);\n\tif (!is_array(input))\n\t\treturn (\n\t\t\t'Postprocessor error: invalid input type for the first argument. ' +\n\t\t\t'It should be either an array or a JSON stringified array, but ' +\n\t\t\t\"the argument given is of type '\" +\n\t\t\ttypeof input +\n\t\t\t\"'.\"\n\t\t);\n\t/* Reading the options */\n\tif (is_number(mode)) mode = mode_from_number_code(mode);\n\tif (is_string(mode)) {\n\t\tvar with_spaces = among('S', mode);\n\t\tvar with_morphology = among('M', mode);\n\t\tvar with_terminators = among('T', mode);\n\t\tvar with_trimming = !among('R', mode);\n\t\tvar with_selmaho = among('C', mode);\n\t\tvar with_nodes_labels = among('N', mode);\n\t\tvar with_json_format = among('J', mode);\n\t\tvar with_indented_json = among('I', mode);\n\t\tvar without_leaf_prefix = among('!', mode);\n\t\tvar with_glossing = among('G', mode);\n\t} else throw 'camxes_postprocessing(): Invalid mode argument type!';\n\t/* Calling the postprocessor */\n\tvar output = newer_postprocessor(\n\t\tinput,\n\t\twith_morphology,\n\t\twith_spaces,\n\t\twith_terminators,\n\t\twith_trimming,\n\t\twith_selmaho,\n\t\twith_nodes_labels,\n\t\twithout_leaf_prefix,\n\t\twith_glossing\n\t);\n\tif (output === null) output = [];\n\t/* Converting the parse tree into JSON format */\n\toutput = JSON.stringify(output, undefined, with_indented_json ? 2 : 0);\n\tif (with_json_format || with_indented_json) return output;\n\t/* Getting rid of \" and , characters */\n\toutput = output.replace(/\\\"/gm, '');\n\tif (with_selmaho) output = output.replace(/\\[([a-zA-Z0-9_-]+),\\[/gm, '[$1: [');\n\toutput = output.replace(/,/gm, ' ');\n\t/* Bracket prettification */\n\treturn prettify_brackets(output);\n}\n\n/* Function for translating the legacy option encoding to the new format. */\n/* For backward compatibility. */\nfunction mode_from_number_code(legacy_mode) {\n\tvar mode = '';\n\tif (legacy_mode & 8) mode += 'S';\n\tif (legacy_mode & 16) mode += 'M';\n\tlegacy_mode = legacy_mode % 8;\n\tif (legacy_mode == 0) mode += 'I';\n\tif (legacy_mode == 1) mode += 'J';\n\tif (legacy_mode <= 1) mode += 'R';\n\tif (legacy_mode > 2 && legacy_mode != 5) mode += 'C';\n\tif (legacy_mode == 4 || legacy_mode == 7) mode += 'N';\n\tif (legacy_mode < 5) mode += 'T';\n\treturn mode;\n}\n\n// ========================================================================== //\n\n/*\n * This function adapts the options passed as arguments into a format adapted\n * to the more generalized 'process_parse_tree' function, and then calls this\n * latter.\n */\nfunction newer_postprocessor(\n\tparse_tree,\n\twith_morphology,\n\twith_spaces,\n\twith_terminators,\n\twith_trimming,\n\twith_selmaho,\n\twith_nodes_labels,\n\twithout_leaf_prefix,\n\twith_glossing\n) {\n\tif (!is_array(parse_tree)) return null;\n\t/* Building a map of node names to node value replacements */\n\tif (with_spaces) var value_substitution_map = { spaces: '_', initial_spaces: '_' };\n\telse var value_substitution_map = {};\n\t/* Building a map of node names to name replacements */\n\tvar name_substitution_map = {\n\t\t// \"cmene\": \"C\", \"cmevla\": \"C\", \"gismu\": \"G\", \"lujvo\": \"L\",\n\t\t// \"fuhivla\": \"Z\", \"prenex\": \"PRENEX\", \"sentence\": \"BRIDI\",\n\t\t// \"selbri\": \"SELBRI\", \"sumti\": \"SUMTI\"\n\t\troot: 'R',\n\t\tfreeform_content: 'F'\n\t};\n\n\tif (!with_trimming) name_substitution_map = {};\n\tvar special_selmaho = [ 'particle', 'root', 'borrowing', 'freeform_variable', 'foreign_quote_content' ];\n\t/** Building a node_action_for() function from the selected options **/\n\tif (with_morphology)\n\t\tvar is_flattening_target = function(tree) {\n\t\t\treturn false;\n\t\t};\n\telse\n\t\tvar is_flattening_target = function(tree) {\n\t\t\tvar targets = special_selmaho;\n\t\t\treturn among(tree[0], targets) || is_family(tree[0]);\n\t\t};\n\tvar is_branch_removal_target = function(tree) {\n\t\tif (!with_spaces && among(tree[0], [ 'spaces', 'initial_spaces' ])) return true;\n\t\treturn !with_terminators && is_family(tree[0]) && tree.length == 1;\n\t};\n\tvar whitelist = [];\n\tif (with_selmaho) whitelist = whitelist.concat(special_selmaho);\n\t// if (with_nodes_labels)\n\t//     whitelist = whitelist.concat([\"prenex\", \"sentence\", \"selbri\", \"sumti\"]);\n\tvar is_node_trimming_target = function(tree) {\n\t\tif (!with_trimming) return false;\n\t\tif (with_terminators && is_family(tree[0]) && tree.length == 1) return false;\n\t\tif (with_selmaho && is_family(tree[0])) return false;\n\t\treturn !among(tree[0], whitelist);\n\t};\n\tvar node_action_for = function(node) {\n\t\tif (is_branch_removal_target(node)) return 'DEL';\n\t\tvar ft = is_flattening_target(node);\n\t\tvar tt = is_node_trimming_target(node);\n\t\tif (ft && tt) return 'TRIMFLAT';\n\t\tif (ft) return 'FLAT';\n\t\tif (tt) return 'TRIM';\n\t\tif (with_trimming && node.length == 1) return 'UNBOX';\n\t\treturn 'PASS';\n\t};\n\t/* Calling process_parse_tree() with the arguments we've built for it */\n\treturn process_parse_tree(\n\t\tparse_tree,\n\t\tvalue_substitution_map,\n\t\tname_substitution_map,\n\t\tnode_action_for,\n\t\t(with_nodes_labels || with_selmaho) && !without_leaf_prefix,\n\t\twith_glossing\n\t);\n}\n\n/*\n * Recursive function for editing a parse tree. Performs a broad range of\n * editions depending on the given arguments. Returns the edited parse tree.\n * \n *  value_substitution_map [Map]:\n *     A map of node names to node value replacements. Used to override the\n *     content of specific leaf nodes.\n *  name_substitution_map [Map]:\n *     A map of node names to node name replacements. Used to rename specific\n *     nodes.\n *  node_action_for [Function: Array -> String]:\n *     A function for deriving the appropriate edition action for the argument\n *     parse tree node; returns an action name, whose possible values are:\n *      'DEL':  Triggers deletion of the current tree branch.\n *      'TRIM': Triggers pruning of the current node; the node name is erased\n *               and if it has only one child node, this child node replaces it.\n *      'FLAT': Triggers flattening of the current tree branch; all its\n *               terminal leaves values are concatenated and the concatenation\n *               results replaces the content of the branch.\n *      'TRIMFLAT': Same as 'FLAT' but also removes the current node.\n *      'UNBOX':    If the current node contains only one element, this element\n *                   replaces the current node.\n *      'PASS':     Does nothing.\n *  must_prefix_leaf_labels [Boolean]:\n *     If true, remaining node names get a colon appended to them, and if they\n *     contain a single leaf value, they get concatenated with their value, and\n *     the concatenation result would replace the node itself.\n *     For example, a terminal node [\"UI\",\"ui\"] would become \"UI:ui\" (note that\n *     the brackets disappeared).\n */\nfunction process_parse_tree(\n\tparse_tree,\n\tvalue_substitution_map,\n\tname_substitution_map,\n\tnode_action_for,\n\tmust_prefix_leaf_labels,\n\twith_glossing\n) {\n\tif (parse_tree.length == 0) return null;\n\tvar action = node_action_for(parse_tree);\n\tif (action == 'DEL') return null; // Deleting the current branch.\n\tvar has_name = is_string(parse_tree[0]);\n\t// Getting the value replacement for this node, if any.\n\tvar substitution_value = has_name ? value_substitution_map[parse_tree[0]] : undefined;\n\tif (has_name) {\n\t\tif (action == 'TRIM') {\n\t\t\t/* If there's a value replacement for this node, we return it\n               instead of the node's content. */\n\t\t\tif (typeof substitution_value !== 'undefined') return substitution_value;\n\t\t\t/* Otherwise the first step of a trim action is to remove the node\n               name. */\n\t\t\tparse_tree.splice(0, 1);\n\t\t\thas_name = false;\n\t\t} else {\n\t\t\t/* No trimming, so let's see if the node name is in the renaming\n               list. If so, let's rename it accordingly. */\n\t\t\tvar v = name_substitution_map[parse_tree[0]];\n\t\t\tif (typeof v !== 'undefined') parse_tree[0] = v;\n\t\t\t/* If there's a value replacement for this node, it becomes the\n               unique value for the node. */\n\t\t\tif (typeof substitution_value !== 'undefined') return [ parse_tree[0], substitution_value ];\n\t\t}\n\t}\n\tif (action == 'FLAT') {\n\t\t/* Flattening action. All the terminal nodes of the branch are\n           concatenated, and the concatenation result replaces the branch's\n           content, alongside the node name if any. If the concatenation\n           result is empty, the branch becomes empty. */\n\t\tvar r = join_expr(parse_tree);\n\t\tif (has_name && r != '') {\n\t\t\tif (must_prefix_leaf_labels) return parse_tree[0] + ':' + r;\n\t\t\telse return [ parse_tree[0], r ];\n\t\t} else if (has_name) return parse_tree[0];\n\t\telse return r;\n\t} else if (action == 'TRIMFLAT') return join_expr(parse_tree);\n\t/* Now we'll iterate over all the other elements of the current node. */\n\tvar i = has_name ? 1 : 0;\n\twhile (i < parse_tree.length) {\n\t\tif (is_array(parse_tree[i])) {\n\t\t\t/* Recursion */\n\t\t\tparse_tree[i] = process_parse_tree(\n\t\t\t\tparse_tree[i],\n\t\t\t\tvalue_substitution_map,\n\t\t\t\tname_substitution_map,\n\t\t\t\tnode_action_for,\n\t\t\t\tmust_prefix_leaf_labels,\n\t\t\t\twith_glossing\n\t\t\t);\n\t\t}\n\t\t/* The recursion call on the current element might have set it to null\n           as a request for deletion. */\n\t\tif (parse_tree[i] === null) parse_tree.splice(i, 1);\n\t\telse i++; // No deletion, so let's go to the next element.\n\t}\n\t/* Now we've finished iterating over the node elements. Let's proceed to\n       the final steps. */\n\t/* If 'must_prefix_leaf_labels' is set and the node has a name and contains\n       at least one other element, we append ':' to its name. */\n\t//    if (has_name && parse_tree.length >= 2 && must_prefix_leaf_labels) {\n\t//        parse_tree[0] += ':';\n\t//    }\n\t/* If the node is empty, we return null as a signal for deletion. */\n\tif (i == 0) return null;\n\telse if (i == 1 && action != 'PASS') {\n\t\t/* If the node contains only one element and we want to trim the node,\n       it gets replaced by its content. */\n\n\t\t// if (with_glossing && glosser.words[parse_tree[0]]) {\n\t\t// \tparse_tree[0] = \"'\" + glosser.words[parse_tree[0]].short + \"'\";\n\t\t// }\n\t\treturn parse_tree[0];\n\t} else if (must_prefix_leaf_labels && i == 2 && has_name && is_string(parse_tree[1])) {\n\t\t/* If 'must_prefix_leaf_labels' is set and the node is a pair of string,\n       we return the concatenation of both strings separated with a colon. */\n\t\tif (!parse_tree[1].includes(':')) return parse_tree[0] + ':' + parse_tree[1];\n\t\telse parse_tree[0] += ':';\n\t}\n\treturn parse_tree;\n}\n\n// ========================================================================== //\n\n/* This function returns the string resulting from the recursive concatenation\n * of all the leaf elements of the parse tree argument (except node names). */\n// \"join_leaves\" or \"flatten_tree\" might be better names.\nfunction join_expr(n) {\n\tif (n.length < 1) return '';\n\tvar s = '';\n\tvar i = is_array(n[0]) ? 0 : 1;\n\twhile (i < n.length) {\n\t\ts += is_string(n[i]) ? n[i] : join_expr(n[i]);\n\t\ti++;\n\t}\n\treturn s;\n}\n\nfunction among(v, s) {\n\tvar i = 0;\n\twhile (i < s.length) if (s[i++] == v) return true;\n\treturn false;\n}\n\n// function is_family(v) {\n// \tif (!is_string(v)) return false;\n// \t// return v.startsWith(\"p_\");\n// \treturn 0 == v.search(/^[BCDFGJKLMNPRSTVXZ]?([AEIOUQH])+$/g);\n// }\n\n// ========================================================================== //\n\n/*\n * Bracket prettification for textual rendering of parse trees.\n */\nfunction prettify_brackets(str) {\n\tvar open_brackets = [ '(', '[', '{', '<' ];\n\tvar close_brackets = [ ')', ']', '}', '>' ];\n\tvar brackets_number = 4;\n\t//\tvar numset = ['0','1','2','3','4','5','6','7','8','9'];\n\tvar numset = [ '\\u2070', '\\u00b9', '\\u00b2', '\\u00b3', '\\u2074', '\\u2075', '\\u2076', '\\u2077', '\\u2078', '\\u2079' ];\n\tvar i = 0;\n\tvar floor = 0;\n\twhile (i < str.length) {\n\t\tif (str[i] == '[') {\n\t\t\tvar n = floor % brackets_number;\n\t\t\tvar num = floor && !n ? str_print_uint(floor / brackets_number, numset) : '';\n\t\t\tstr = str_replace(str, i, 1, open_brackets[n] + num);\n\t\t\tfloor++;\n\t\t} else if (str[i] == ']') {\n\t\t\tfloor--;\n\t\t\tvar n = floor % brackets_number;\n\t\t\tvar num = floor && !n ? str_print_uint(floor / brackets_number, numset) : '';\n\t\t\tstr = str_replace(str, i, 1, num + close_brackets[n]);\n\t\t}\n\t\ti++;\n\t}\n\treturn str;\n}\n\n/* ================== */\n/* ===  Routines  === */\n/* ================== */\n\nfunction str_print_uint(val, charset) {\n\t// 'charset' must be a character array.\n\tvar radix = charset.length;\n\tvar str = '';\n\tval -= val % 1; // No float allowed\n\twhile (val >= 1) {\n\t\tstr = charset[val % radix] + str;\n\t\tval /= radix;\n\t\tval -= val % 1;\n\t}\n\treturn str;\n}\n\nfunction str_replace(str, pos, len, sub) {\n\tif (pos < str.length) {\n\t\tif (pos + len >= str.length) len -= pos + len - str.length;\n\t\treturn str.substring(0, pos) + sub + str.substring(pos + len);\n\t} else return str;\n}\n\nmodule.exports.postprocessing = camxes_postprocessing;\nmodule.exports.postprocess = camxes_postprocessing; // Alias\nmodule.exports.process_parse_tree = process_parse_tree;\nmodule.exports.prettify_brackets = prettify_brackets;\n\n//# sourceURL=webpack://bundle/./src/process_parse_tree.js?");

/***/ }),

/***/ "./src/simplify_tree.js":
/*!******************************!*\
  !*** ./src/simplify_tree.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { is_string } = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\n// List of important types in eberban that we want to show up in the simplified\n// tree.\nconst important_types = [\n\t// text\n\t[ 'text', 'text' ],\n\t[ 'paragraph', 'paragraph' ],\n\t[ 'paragraph_unit', 'paragraph unit' ],\n\t[ 'paragraph_unit_erased', 'erased' ],\n\t[ 'definition', 'definition' ],\n\t[ 'sentence', 'sentence' ],\n\n\t// scope\t\n\t[ 'scope', 'scope' ],\n\t[ 'scope_sequence', 'sequence' ],\n\t[ 'scope_sequence_item', 'sequence item' ],\n\t[ 'chaining', 'chaining' ],\n\t[ 'chaining_neg', 'chaining negation' ],\n\t[ 'chaining_unit', 'chaining unit' ],\n\t[ 've_scope', 'VE-scope' ],\n\t[ 've_scope_first', 'explicit switch' ],\n\t[ 've_scope_next', 'explicit switch' ],\n\t[ 'arguments_list', 'arguments' ],\n\t[ 'defined', 'defined predicate'],\n\n\t// predicates\n\t[ 'predicate', 'predicate' ],\n\t[ 'compound', 'compound' ],\n\t[ 'borrowing_group', 'borrowing group' ],\n\t[ 'borrowing', 'borrowing' ],\n\t[ 'freeform_variable', 'freeform variable'],\n\t[ 'freeform_content', 'freeform' ],\n\t[ 'grammatical_quote', 'quote' ],\n\t[ 'one_word_quote', 'word quote' ],\n\t[ 'foreign_quote', 'foreign quote' ],\n\t[ 'foreign_quote_content', 'foreign quote content' ],\n\t[ 'unit_number', 'number' ],\n\t[ 'predicate_scope', 'predicate scope' ],\n\n\t// free\n\t[ 'free_metadata', 'metadata' ],\n\t[ 'free_interjection', 'interjection' ],\n\t[ 'free_parenthetical', 'parenthetical' ],\n\t[ 'free_subscript', 'subscript' ],\n\t[ 'override', 'override' ],\n];\n\n// List of simplifying functions.\nvar simplifyFunctions = {};\n\n// Fills the simplify functions list with important types.\nfor (let replace of important_types) {\n\tsimplifyFunctions[replace[0]] = function(parse) {\n\t\treturn {\n\t\t\ttype: replace[1],\n\t\t\tchildren: simplifyArrayOfTrees(parse.slice(1))\n\t\t};\n\t};\n}\n\nsimplifyFunctions['foreign_quote_content'] = function(parse) {\n\tlet text = '';\n\n\tparse.slice(1).forEach(x => {\n\t\ttext += x[0];\n\t})\n\n\treturn {\n\t\ttype: 'foreign quote content',\n\t\tword: text,\n\t}\n}\n\nvar importantTypesMap = {};\n\n// Convert important types array to map.\nfor (let type of important_types) {\n\timportantTypesMap[type[0]] = type[1];\n}\n\n\n/**\n * This file contains functions that simplify the parse tree returned by camxes.js.\n * \n * The original parse tree has the following structure:\n * [\n *   \"...\",   // the type\n *   ...      // children as array elements\n * ]\n * Here, the first element of every array indicates the type of the object parsed, and the\n * next objects are the children of the element.\n * \n * The simplified parse tree has quite another structure:\n * [\n *   {\n *     type: \"...\",\n *     children: [ ... ],   // only one of children and word\n *     word: \"...\",\n *     ...: ...             // other optional elements\n *   }\n * ]\n * Here, type gives the type. For non-terminals, children is an array containing the children.\n * For terminals, word contains the actual word parsed. (Of course, one cannot have both\n * children and word.) Furthermore, there can be more elements added to this structure to add\n * additional information as needed.\n */\n\n/**\n * Simplifies the given parse tree. Returns an array.\n */\nfunction simplifyTree(parse) {\n\t// if it is a terminal, just return that\n\tif (parse.length == 2 && is_string(parse[0]) && is_string(parse[1])) {\n\t\tlet type = parse[0];\n\n\t\tif (importantTypesMap[type] != undefined)\n\t\t\ttype = importantTypesMap[type];\n\n\t\treturn [\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tword: parse[1]\n\t\t\t}\n\t\t];\n\t}\n\n\tvar f = simplifyFunctions[parse[0]];\n\n\t// if there is a simplification function, apply it\n\tif (f) {\n\t\treturn [ f(parse) ];\n\t}\n\n\t// else, we recursively search the children for things we do have a simplification function for\n\tvar result;\n\tif (is_string(parse[0])) {\n\t\tresult = simplifyArrayOfTrees(parse.slice(1));\n\t} else {\n\t\tresult = simplifyArrayOfTrees(parse);\n\t}\n\n\treturn result;\n}\n\n/**\n * Simplifies an array of trees.\n */\nfunction simplifyArrayOfTrees(parse) {\n\tvar result = [];\n\n\tfor (var i in parse) {\n\t\tresult = result.concat(simplifyTree(parse[i]));\n\t}\n\n\treturn result;\n}\n\nmodule.exports.simplifyTree = simplifyTree;\n\n//# sourceURL=webpack://bundle/./src/simplify_tree.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/***/ ((module) => {

eval("function remove_spaces(tree) {\n    if (tree.length > 0 && among(tree[0], [\"spaces\", \"initial_spaces\"])) return null;\n    var i = 0;\n    while (i < tree.length) {\n        if (is_array(tree[i])) {\n            tree[i] = remove_spaces(tree[i]);\n            if (tree[i] === null) tree.splice(i--, 1);\n        }\n        i++;\n    }\n    return tree;\n}\n/*\n * EXAMPLE OF PARSE TREE PRUNING PROCEDURE\n * \n * remove_morphology(parse_tree)\n * \n * This function takes a parse tree, and joins the expressions of the following\n * nodes:\n * \"cmevla\", \"gismu_2\", \"lujvo\", \"fuhivla\", \"spaces\"\n * as well as any selmaho node (e.g. \"KOhA\").\n * \n */\n\nfunction remove_morphology(pt) {\n    if (pt.length < 1) return [];\n    var i;\n    /* Sometimes nodes have no label and have instead an array as their first\n       element. */\n    if (is_array(pt[0])) i = 0;\n    else { // The first element is a label (node name).\n        // Let's check if this node is a candidate for our pruning.\n        if (is_target_node(pt)) {\n            /* We join recursively all the terminal elements (letters) in this\n             * node and its child nodes, and put the resulting string in the #1\n             * slot of the array; afterwards we delete all the remaining elements\n             * (their terminal values have been concatenated into pt[1]). */\n            pt[1] = join_expr(pt);\n            // If pt[1] contains an empty string, let's delete it as well:\n            pt.splice((pt[1] == \"\") ? 1 : 2);\n            return pt;\n        }\n        i = 1;\n    }\n    /* If we've reached here, then this node is not a target for pruning, so let's\n       do recursion into its child nodes. */\n    while (i < pt.length) {\n        if (is_array(pt[i])) remove_morphology(pt[i]);\n        i++;\n    }\n    return pt;\n}\n\n/* This function returns the string resulting from the recursive concatenation of\n * all the leaf elements of the parse tree argument (except node names). */\nfunction join_expr(n) {\n    if (n.length < 1) return \"\";\n    var s = \"\";\n    var i = is_array(n[0]) ? 0 : 1;\n    while (i < n.length) {\n        s += is_string(n[i]) ? n[i] : join_expr(n[i]);\n        i++;\n    }\n    return s;\n}\n\n/* Checks whether the argument node is a target for pruning. */\nfunction is_target_node(n) {\n    return (among(n[0], [\"particle\", \"root\", \"borrowing\", \"freeform_variable\"])\n            || is_family(n[0]));\n}\n\nfunction among(v, s) {\n    var i = 0;\n    while (i < s.length) if (s[i++] == v) return true;\n    return false;\n}\n\nfunction is_family(v) {\n    if (!is_string(v)) return false;\n    return 0 == v.search(/^[BCDFGJKLMNPRSTVXZ]?([AEIOUH])+$/g);\n}\n\nfunction is_string(v) {\n    return Object.prototype.toString.call(v) === '[object String]';\n}\n\nfunction is_array(v) {\n    return Object.prototype.toString.call(v) === '[object Array]';\n}\n\nfunction is_number(v) {\n\treturn Object.prototype.toString.call(v) === '[object Number]';\n}\n\nmodule.exports.remove_spaces = remove_spaces;\nmodule.exports.remove_morphology = remove_morphology;\nmodule.exports.join_expr = join_expr;\nmodule.exports.is_target_node = is_target_node;\nmodule.exports.among = among;\nmodule.exports.is_family = is_family;\nmodule.exports.is_string = is_string;\nmodule.exports.is_array = is_array;\nmodule.exports.is_number = is_number;\n\n\n//# sourceURL=webpack://bundle/./src/util.js?");

/***/ }),

/***/ "./webpack/parser.js":
/*!***************************!*\
  !*** ./webpack/parser.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"camxes\": () => (/* binding */ camxes),\n/* harmony export */   \"postprocessing\": () => (/* binding */ postprocessing),\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\nconst { camxes } = __webpack_require__(/*! ../grammar/eberban */ \"./grammar/eberban.js\");\nconst { remove_morphology, remove_spaces } = __webpack_require__(/*! ../src/util */ \"./src/util.js\");\nconst { simplifyTree } = __webpack_require__(/*! ../src/simplify_tree */ \"./src/simplify_tree.js\");\nconst { postprocessing } = __webpack_require__(/*! ../src/process_parse_tree */ \"./src/process_parse_tree.js\");\n\nconst { dictionary_en: dictionary } = __webpack_require__(/*! ../src/dictionary */ \"./src/dictionary.js\");\n\nconst hideTitleList = [\n\t'paragraph',\n\t'paragraph unit',\n\t'sentence',\n\t'definition',\n\t'scope',\n\t'sequence item',\n\t'predicate',\n\t'chaining unit',\n\t'chaining negation',\n\t'VE-scope',\n\t'borrowing group',\n\t'erased'\n];\n\nconst hideFamily = [\n\t'a',\n\t'e',\n\t'i',\n\t'o',\n\t'u',\n\t'freeform_content',\n\t'foreign quote content',\n]\n\n// List of types with their associated CSS classes.\nconst boxClassForTypeMap = new Map([\n\t// text\n\t[ 'paragraph', 'box box-paragraph' ],\n\t[ 'paragraph unit', 'box box-paragraph-unit' ],\n\t[ 'erased', 'erased' ],\n\t[ 'sentence', 'box box-sentence' ],\n\t[ 'definition', 'box box-sentence' ],\n\t[ 'arguments', 'box box-arguments' ],\n\t[ 'defined predicate', 'box box-arguments' ],\n\n\t// scope\n\t[ 'scope', 'box box-scope' ],\n\t[ 'sequence item', 'box box-scope-highlight' ],\n\t[ 'chaining unit', 'box box-chaining-unit' ],\n\t[ 'chaining negation', 'box box-chaining-neg' ],\n\t[ 'VE-scope', 'box box-va-scope' ],\n\n\t// units\n\t[ 'predicate', 'box box-predicate' ],\n\t[ 'quote', 'box box-predicate' ],\n\t[ 'word quote', 'box box-predicate' ],\n\t[ 'foreign quote', 'box box-borrowing foreign-quote' ],\n\t[ 'compound', 'box box-compound' ],\n\t[ 'number', 'box box-number' ],\n\t[ 'letters', 'box box-letters' ],\n\t[ 'subscope', 'box box-subscope' ],\n\t[ 'borrowing group', 'box box-borrowing' ],\n\t[ 'foreign quote content', 'box box-not-shown foreign-quote-content'],\n\n\t// free\n\t[ 'metadata', 'box box-note' ],\n\t[ 'interjection', 'box box-note' ],\n\t[ 'subscript', 'box box-note' ],\n\t[ 'parenthetical', 'box box-note' ],\n\t[ 'override', 'box box-note' ],\n]);\n\nfunction boxClassForType(parse) {\n\tlet boxClass = boxClassForTypeMap.get(parse.type);\n\treturn boxClass || 'box box-not-shown';\n}\n\nfunction escapeHtml(str) {\n\tvar p = document.createElement('p');\n\tp.appendChild(document.createTextNode(str));\n\treturn p.innerHTML;\n}\n\n/**\n * Launches the parsing process by calling the parser with the data entered in the interface,\n * and processing the results.\n */\nfunction parse() {\n\tvar textToParse = $('#input_textarea').val();\n\t$('#result-row').slideDown();\n\ttry {\n\t\tvar start = new Date().getTime();\n\t\ttextToParse = ' ' + textToParse; // add initial space to help parser\n\t\tvar parse = camxes.parse(textToParse);\n\t\tvar end = new Date().getTime();\n\t\t$('#time-label').html('(parsing took ' + (end - start) + ' ms)');\n\t\tparse = remove_morphology(parse);\n\t\tparse = remove_spaces(parse);\n\t\tvar simplified = simplifyTree(parse);\n\n\t\tif (parse) {\n\t\t\tvar tokens = [];\n\t\t\tfindTokens(parse, tokens);\n\n\t\t\t// var $parseResultHighlighted = $('#parse-result-highlighted');\n\t\t\t// showHighlighting(simplified[0], tokens, $parseResultHighlighted);\n\n\t\t\tvar $parseResultRaw = $('#parse-result-raw');\n\t\t\tshowRawTree(parse, $parseResultRaw);\n\n\t\t\tvar $parseResultTree = $('#parse-result-tree');\n\t\t\tshowParseTree(parse, $parseResultTree);\n\n\t\t\tvar $parseResultSimplified = $('#parse-result-simplified');\n\t\t\tshowSimplifiedTree(simplified, $parseResultSimplified);\n\n\t\t\tvar $parseResultBoxes = $('#parse-result-boxes');\n\t\t\tshowBoxes(simplified, $parseResultBoxes);\n\n\t\t\tvar $parseResultGlossing = $('#parse-result-glossing');\n\t\t\tshowGlossing(tokens, $parseResultGlossing);\n\t\t}\n\t\t// $('#parse-result-highlighted-tab').html('Highlighted');\n\t\t$('#parse-result-tree-tab').html('Parse tree');\n\t\t$('#parse-result-raw-tab').html('Raw tree');\n\t\t$('#parse-result-simplified-tab').html('Simplified tree');\n\t\t$('#parse-result-boxes-tab').html('Boxes');\n\t\t$('#parse-result-glossing-tab').html('Glosses');\n\t} catch (e) {\n\t\tif (e.name && e.name === 'SyntaxError') {\n\t\t\t// $('#parse-result-highlighted-tab').html('<span class=\"muted\">Highlighted</span>');\n\t\t\t// showSyntaxError(e, textToParse, $('#parse-result-highlighted'));\n\t\t\t$('#parse-result-raw-tab').html('<span class=\"muted\">Raw tree</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-raw'));\n\t\t\t$('#parse-result-simplified-tab').html('<span class=\"muted\">Simplified tree</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-simplified'));\n\t\t\t$('#parse-result-tree-tab').html('<span class=\"muted\">Parse tree</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-tree'));\n\t\t\t$('#parse-result-boxes-tab').html('<span class=\"muted\">Boxes</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-boxes'));\n\t\t\t$('#parse-result-glossing-tab').html('<span class=\"muted\">Glosses</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-glossing'));\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n\n/**\n * Finds all tokens in the resulting parse tree, and puts them in the tokens array.\n */\nfunction findTokens(parse, tokens) {\n\tif (parse instanceof Array) {\n\t\tif (parse.length == 2 && isString(parse[0]) && isString(parse[1])) {\n\t\t\ttokens.push(parse[1]);\n\t\t} else {\n\t\t\tfor (var child in parse) {\n\t\t\t\tfindTokens(parse[child], tokens);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Shows the parse result in the interface.\n */\nfunction showRawTree(parse, $element) {\n\t$element.html('<pre>' + JSON.stringify(parse, undefined, 2) + '</pre>');\n}\n\n/**\n * Shows the parse result in the interface.\n */\nfunction showParseTree(parse, $element) {\n\t$element.html(constructParseTreeOutput(parse, 0));\n}\n\nfunction constructParseTreeOutput(parse, depth) {\n\t// precaution against infinite recursion; this should not actually happen of course\n\tif (depth > 50) {\n\t\treturn '<b>too much recursion :-(</b>';\n\t}\n\n\t// if we get null, just print that\n\tif (parse === null) {\n\t\treturn '<i>(none?)</i>';\n\t}\n\n\t// if we get undefined, just print that\n\tif (!parse) {\n\t\treturn '<i>(undefined?)</i>';\n\t}\n\n\tif (parse instanceof Array) {\n\t\tif (parse.length == 0) {\n\t\t\treturn '<i>(empty array?)</i>';\n\t\t}\n\n\t\tvar output = '';\n\n\t\t// what is the type of parse[0]?\n\t\tif (isString(parse[0])) {\n\t\t\t// it is the type\n\t\t\toutput += parse[0] + ':';\n\n\t\t\tif (isString(parse[1])) {\n\t\t\t\t// a literal\n\t\t\t\toutput += ' <b>[' + parse[1] + ']</b>';\n\t\t\t\tif (dictionary[parse[1]]) {\n\t\t\t\t\toutput += ' <span class=\"translation\">' + dictionary[parse[1]].short + '</span>';\n\t\t\t\t}\n\t\t\t\treturn output;\n\t\t\t}\n\n\t\t\toutput += '<ul>';\n\t\t\tfor (var child in parse) {\n\t\t\t\tif (child !== '0') {\n\t\t\t\t\toutput += '<li>' + constructParseTreeOutput(parse[child], depth + 1) + '</li>';\n\t\t\t\t}\n\t\t\t}\n\t\t\toutput += '</ul>';\n\t\t\treturn output;\n\t\t} else {\n\t\t\toutput += '<i>a list:</i>';\n\t\t\toutput += '<ol>';\n\t\t\tfor (var child in parse) {\n\t\t\t\toutput += '<li>' + constructParseTreeOutput(parse[child], depth + 1) + '</li>';\n\t\t\t}\n\t\t\toutput += '</ol>';\n\t\t\treturn output;\n\t\t}\n\t}\n\n\treturn '<i>(huh? ' + parse + ')</i>';\n}\n\n/**\n * Shows the simplified parse tree in the interface.\n */\nfunction showSimplifiedTree(simplified, $element) {\n\t$element.html(constructSimplifiedTreeOutput(simplified[0], 0));\n}\n\nfunction constructSimplifiedTreeOutput(parse, depth) {\n\t// precaution against infinite recursion; this should not actually happen of course\n\tif (depth > 50) {\n\t\treturn '<b>too much recursion :-(</b>';\n\t}\n\n\t// if we get null, just print that\n\tif (parse === null) {\n\t\treturn '<i>(none?)</i>';\n\t}\n\n\t// if we get undefined, just print that\n\tif (!parse) {\n\t\treturn '<i>(undefined?)</i>';\n\t}\n\n\tvar output = parse.type;\n\n\tif (parse.word) {\n\t\t// we have a terminal\n\t\tif (parse.type == 'foreign quote content') {\n\t\t\toutput += ' <b>[<span class=\"foreign-quote-content\">' + escapeHtml(parse.word) + '</span>]</b>';\n\t\t} else {\n\t\t\toutput += ' <b>[' + parse.word + ']</b>';\n\t\t}\n\t\tif (dictionary[parse.word]) {\n\t\t\toutput += ' <span class=\"translation\">' + dictionary[parse.word].short + '</span>';\n\t\t}\n\t} else {\n\t\t// we have a non-terminal\n\n\t\toutput += '<ul>';\n\n\t\tfor (var child in parse.children) {\n\t\t\toutput += '<li>';\n\t\t\toutput += constructSimplifiedTreeOutput(parse.children[child], depth + 1);\n\t\t\toutput += '</li>';\n\t\t}\n\n\t\toutput += '</ul>';\n\t}\n\n\treturn output;\n}\n\n/**\n * Shows the boxes in the interface.\n */\nfunction showBoxes(simplified, $element) {\n\tvar output = '';\n\n\toutput += constructBoxesOutput(simplified[0], 0);\n\n\t/*output += \"<p>Legend: \";\n\tvar types = [\"sentence\", \"prenex\", \"selbri\", \"sumti\"];\n\tfor (var type in types) {\n\t\toutput += \"<div class=\\\"\" + boxClassForType({ type: types[type] }) + \"\\\">\" + types[type] + \"</div>\";\n\t}\n\toutput += \"</p>\";*/\n\n\t$element.html(output);\n}\n\nfunction constructBoxesOutput(parse, depth) {\n\t// precaution against infinite recursion; this should not actually happen of course\n\tif (depth > 50) {\n\t\treturn '<b>too much recursion :-(</b>';\n\t}\n\n\t// if we get null, just print that\n\tif (parse === null) {\n\t\treturn '<i>(none?)</i>';\n\t}\n\n\t// if we get undefined, just print that\n\tif (!parse) {\n\t\treturn '<i>(undefined?)</i>';\n\t}\n\n\tvar output = '';\n\n\tif (parse.word) {\n\t\toutput += '<div class=\"box box-terminal';\n\t\t\n\t\tif (parse.css_classes != undefined) {\n\t\t\toutput += ` ${parse.css_classes}`;\n\t\t}\n\n\t\tif (parse.type == 'foreign quote content') {\n\t\t\toutput += \" foreign-quote-content\";\n\t\t}\n\t\t\n\t\toutput += '\">';\n\n\t\t// we have a terminal\n\t\toutput += '&nbsp;<div class=\"tip\">' + escapeHtml(parse.word);\n\n\t\tif (hideFamily.includes(parse.type)) {\n\t\t\toutput += '</div>&nbsp;<br></div>';\n\t\t\treturn output;\n\t\t}\n\n\t\tif (dictionary[parse.word] && dictionary[parse.word].long) {\n\t\t\toutput += '<div class=\"tiptext\">' + escapeHtml(dictionary[parse.word].long) + '</div>';\n\t\t}\n\n\t\toutput += '</div>&nbsp;<br>&nbsp;' + parse.type + '&nbsp;<br>';\n\t\t// escapeHtml(words[text[j]].long)\n\n\t\tif (dictionary[parse.word]) {\n\t\t\tlet short = dictionary[parse.word].short;\n\t\t\tif (short) {\n\t\t\t\toutput += '<span class=\"translation\">&nbsp;' + escapeHtml(short) + '&nbsp;</span>';\n\t\t\t}\n\t\t} else if (['KE', 'GE', 'borrowing', \"freeform variable\"].includes(parse.type)) {\n\t\t\toutput += '';\n\t\t} else {\n\t\t\toutput += '...';\n\t\t}\n\n\t\toutput += '</div>';\n\t} else {\n\t\t// we have a non-terminal\n\n\t\toutput += '<div class=\"' + boxClassForType(parse);\n\n\t\tif (parse.css_classes != undefined) {\n\t\t\toutput += ` ${parse.css_classes}`;\n\t\t}\n\n\t\toutput += '\">';\n\n\t\t// handle erased scope sequence elements\n\t\tif (parse.type === 'sequence')  {\n\t\t\tfor (var child in parse.children) {\n\t\t\t\tif (parse.children[child].word == 'buhu') {\n\t\t\t\t\tparse.children[child].css_classes = 'erased';\n\t\t\t\t\tparse.children[child-1].css_classes = 'erased';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var child in parse.children) {\n\t\t\toutput += constructBoxesOutput(parse.children[child], depth + 1);\n\t\t}\n\n\t\tif (boxClassForType(parse) !== 'box box-not-shown') {\n\t\t\tif (!hideTitleList.includes(parse.type)) {\n\t\t\t\tif (parse.type === 'compound') {\n\t\t\t\t\tlet compound_text = [];\n\t\t\t\t\tlet compound = '';\n\n\t\t\t\t\tfor (var child in parse.children) {\n\t\t\t\t\t\tif (parse.children[child].word) {\n\t\t\t\t\t\t\tcompound_text.push(parse.children[child].word);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (compound_text[0] == 'e') {\n\t\t\t\t\t\tcompound = 'e' + extractCanonicalCompound(compound_text, 1, 2).compound;\n\t\t\t\t\t} else if (compound_text[0] == 'a') {\n\t\t\t\t\t\tcompound += 'a' + extractCanonicalCompound(compound_text, 1, 3).compound;\n\t\t\t\t\t} else if (compound_text[0] == 'o') {\n\t\t\t\t\t\tcompound += 'o' + extractCanonicalCompound(compound_text, 1, -1).compound;\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += '<br><b>' + compound + '</b>';\n\n\t\t\t\t\tif (dictionary[compound]) {\n\t\t\t\t\t\toutput += ' = <div class=\"tip translation\">' + dictionary[compound].short;\n\n\t\t\t\t\t\tif (dictionary[compound].long) {\n\t\t\t\t\t\t\toutput += '<div class=\"tiptext\">' + escapeHtml(dictionary[compound].long) + '</div>';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toutput += '&nbsp;</div>';\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput += ' = <div class=\"tip translation\">???</div>';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput += '<br>' + parse.type;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\toutput += '</div>';\n\t}\n\n\treturn output;\n}\n\n/**\n * Shows a syntax error in the interface.\n */\nfunction showSyntaxError(e, textToParse, $element) {\n\tvar output =\n\t\t'<div class=\"alert\">' +\n\t\t'<p><b>Syntax error</b> on line <b>' +\n\t\te.line +\n\t\t'</b>, at column <b>' +\n\t\te.column +\n\t\t'</b>: ' +\n\t\te.message +\n\t\t'</p>' +\n\t\t'<p class=\"error-sentence\">' +\n\t\tgenerateErrorPosition(e, textToParse) +\n\t\t'</p>' +\n\t\tgenerateFixes(e) +\n\t\t'</div>';\n\n\t$element.html(output);\n}\n\n/**\n * Generates the text sample that shows the error position.\n */\nfunction generateErrorPosition(e, textToParse) {\n\t//\"mi vau <span class=\\\"error-marker\\\">&#9652;</span> do cusku ...\" +\n\n\tvar before = textToParse.substring(e.offset - 20, e.offset);\n\n\tvar after = textToParse.substring(e.offset + 0, e.offset + 20);\n\n\tif (e.offset > 20) {\n\t\tbefore = '...' + before;\n\t}\n\tif (e.offset < textToParse.length - 20) {\n\t\tafter = after + '...';\n\t}\n\n\treturn before + '<span class=\"error-marker\">&#9652;</span>' + after;\n}\n\nfunction generateFixes(e) {\n\tif (!e.fix) {\n\t\t//return \"<p><i>No quick fixes available.</i></p>\";\n\t\treturn '';\n\t}\n\n\tvar fixes = '<p>Quick fixes:<ul>';\n\n\tfor (var f in e.fix) {\n\t\tvar fix = e.fix[f];\n\t\tfixes += '<li>';\n\n\t\tif (fix.fixFunction) {\n\t\t\tfixes += '<a>';\n\t\t\tfixes += fix.name;\n\t\t\tfixes += '</a>';\n\t\t} else {\n\t\t\tfixes += fix.name;\n\t\t}\n\n\t\tfixes += '</li>';\n\t}\n\n\tfixes += '</ul></p>';\n\n\treturn fixes;\n}\n\n/**\n * Shows the highlighting in the interface.\n */\nfunction showHighlighting(simplified, tokens, $element) {\n\tvar output = '';\n\n\tvar mode = 1;\n\tvar classString = 'latin-highlighting';\n\n\t// if ($('#latin-button').hasClass('active')) {\n\t// \tvar mode = 1;\n\t// \tvar classString = 'latin-highlighting';\n\t// } else if ($('#cyrillic-button').hasClass('active')) {\n\t// \tvar mode = 2;\n\t// \tvar classString = 'cyrillic-highlighting';\n\t// } else if ($('#tengwar-button').hasClass('active')) {\n\t// \tvar mode = 3;\n\t// \tvar classString = 'tengwar-highlighting';\n\t// } else if ($('#hiragana-button').hasClass('active')) {\n\t// \tvar mode = 4;\n\t// \tvar classString = 'hiragana-highlighting';\n\t// }\n\n\toutput += '<span class=\"highlighting ' + classString + '\"><big>';\n\toutput += markupHighlighting(simplified, mode);\n\toutput += '</big></span>';\n\n\t$element.html(output);\n}\n\nfunction markupHighlighting(simplified, mode) {\n\tvar output = '';\n\tvar beforeOutput = '';\n\tvar afterOutput = ' ';\n\n\tif (simplified.type === 'selbri') {\n\t\tbeforeOutput += '<span class=\"lojban-selbri\">';\n\t\tafterOutput = '</span> ';\n\t} else if (simplified.type === 'modal sumti') {\n\t\tbeforeOutput += '<span class=\"lojban-modal\"><sup>m</sup>';\n\t\tafterOutput = '</span> ';\n\t} else if (simplified.type === 'sumti x') {\n\t\tif (simplified.sumtiPlace > 5) {\n\t\t\tbeforeOutput += '<span class=\"lojban-sumti6\"><sup>' + simplified.sumtiPlace + '</sup>';\n\t\t\tafterOutput = '</span> ';\n\t\t} else {\n\t\t\tbeforeOutput +=\n\t\t\t\t'<span class=\"lojban-sumti' + simplified.sumtiPlace + '\"><sup>' + simplified.sumtiPlace + '</sup>';\n\t\t\tafterOutput = '</span> ';\n\t\t}\n\t} else if (simplified.type === 'prenex') {\n\t\tbeforeOutput += '<span class=\"lojban-prenex\"><sup>p</sup>';\n\t\tafterOutput = '</span> ';\n\t} else if (simplified.type === 'free') {\n\t\tbeforeOutput += '<span class=\"lojban-vocative\"><sup>v</sup>';\n\t\tafterOutput = '</span> ';\n\t}\n\n\tif (simplified.word) {\n\t\toutput += simplified.word;\n\t} else {\n\t\tif (beforeOutput === '') {\n\t\t\tfor (child in simplified.children) {\n\t\t\t\toutput += markupHighlighting(simplified.children[child], mode);\n\t\t\t}\n\t\t} else {\n\t\t\toutput += '<span class=\"lojban-nesting\">' + enumerateTokens(simplified, mode) + '</span>';\n\t\t}\n\t}\n\n\treturn beforeOutput + output + afterOutput;\n}\n\nfunction enumerateTokens(simplified, mode) {\n\tvar output = '';\n\n\tif (simplified.word) {\n\t\toutput += simplified.word;\n\t} else {\n\t\tfor (child in simplified.children) {\n\t\t\tvar textToAdd = enumerateTokens(simplified.children[child], mode);\n\t\t\tif (textToAdd) {\n\t\t\t\toutput += textToAdd + ' ';\n\t\t\t}\n\t\t}\n\t}\n\n\tif (endsWith(output, ' ')) {\n\t\toutput = output.substring(0, output.length - 1);\n\t}\n\n\treturn output;\n}\n\n/**\n * Shows the glossing in the interface.\n */\nfunction showGlossing(text, $element) {\n\tvar output = '<dl class=\"glosser-definition dl-horizontal\">';\n\n\tlet skip_compound = 0;\n\tvar definitions = {};\n\n\tfor (var j = 0; j < text.length; j++) {\n\t\tlet word = text[j];\n\n\t\tif (skip_compound == 0) {\n\t\t\tlet compound = '';\n\n\t\t\tif (word == 'e') {\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, 2));\n\t\t\t} else if (word == 'a') {\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, 3));\n\t\t\t} else if (word == 'o') {\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, -1));\n\t\t\t}\n\n\t\t\tword += compound;\n\t\t} else {\n\t\t\tskip_compound--;\n\t\t}\n\n\t\tif (word == 'u') {\n\t\t\t// skip next word which is the borrowing content\n\t\t\tj++;\n\t\t} else if (word != 'o' && dictionary[word]) {\n\t\t\tif (!definitions[word]) {\n\t\t\t\tdefinitions[word] = [\n\t\t\t\t\tdictionary[word].family,\n\t\t\t\t\tdictionary[word].long ? escapeHtml(dictionary[word].long) : dictionary[word].short\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t}\n\n\tdefinitions = sortMapByKey(definitions);\n\n\tfor (var key in definitions) {\n\t\toutput += '<dt>' + key + '</dt>';\n\t\toutput += '<dd><span class=\"gloss-family\">' + definitions[key][0] + '</span>' + definitions[key][1] + '</dd>';\n\t}\n\n\toutput += '</dl>';\n\n\t$element.html(output);\n}\n\nfunction sortMapByKey(map) {\n\tvar tupleArray = [];\n\tfor (var key in map) tupleArray.push([ key, map[key] ]);\n\ttupleArray.sort(function(a, b) {\n\t\treturn a[0] > b[0];\n\t});\n\tvar sortedMap = {};\n\ttupleArray.forEach(function(el) {\n\t\tsortedMap[el[0]] = el[1];\n\t});\n\treturn sortedMap;\n}\n\nfunction extractCanonicalCompound(text, startIndex, length) {\n\tlet offset = 0;\n\tlet compound = '';\n\n\twhile (length != 0) {\n\t\tlet item = text[startIndex + offset];\n\n\t\t// o terminator\n\t\tif (item == 'o') {\n\t\t\tcompound += ' o';\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (item == 'u') {\n\t\t\tcompound += ' ' + item + text[startIndex + offset + 1];\n\t\t\toffset++;\n\t\t} else {\n\t\t\tcompound += ' ' + item;\n\t\t}\n\n\t\toffset++;\n\t\tlength--;\n\t}\n\n\treturn { compound, offset };\n}\n\n/**\n * Shows the translation in the interface.\n */\nfunction showTranslation(parse, text, $element) {\n\tvar output =\n\t\t'<p class=\"muted\">This translation feature tries to give an approximate translation of the Lojban text into English. However, it does only work for a few sentences as of now. (Try [mi gleki] or something simple like that...)</p>';\n\n\t//var translation = translate(parse);\n\tvar translation = 'Sorry! Translation is switched off at the moment, to prevent crashes in the other parts :-(';\n\toutput += '<center><big>' + translation + '</big></center>';\n\n\t$element.html(output);\n}\n\n// Auxiliary\n\nfunction isString(s) {\n\treturn typeof s === 'string' || s instanceof String;\n}\n\nfunction endsWith(str, suffix) {\n\treturn str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\n\n\n//# sourceURL=webpack://bundle/./webpack/parser.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./webpack/parser.js");
/******/ 	bundle = __webpack_exports__;
/******/ 	
/******/ })()
;